"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[953],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=p(n),d=i,h=m["".concat(s,".").concat(d)]||m[d]||c[d]||r;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4698:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const r={slug:"text-io-flaw",title:"The flaw that reduces C# and .NET popularity",tags:["text_io"]},o="Text input parsing: the flaw that reduces C# and .NET popularity",l={permalink:"/text-io-flaw",source:"@site/blog/2022-10-06-plain-text-io-flaw.md",title:"The flaw that reduces C# and .NET popularity",description:"In competitive programming contests, interviews, or when solving problems from archives for learning we are facing automatic judging systems. These systems accept code on some supported language, then compile and run it against many test cases.",date:"2022-10-06T00:00:00.000Z",formattedDate:"October 6, 2022",tags:[{label:"text_io",permalink:"/tags/text-io"}],readingTime:4.755,hasTruncateMarker:!0,authors:[],frontMatter:{slug:"text-io-flaw",title:"The flaw that reduces C# and .NET popularity",tags:["text_io"]},prevItem:{title:"Text IO Performance",permalink:"/plain-text-io-perf"}},s={authorsImageUrls:[]},p=[{value:"The Flaw",id:"the-flaw",level:2},{value:"C:",id:"c",level:4},{value:"C++:",id:"c-1",level:4},{value:"Kotlin (Java solution similar to it, but much longer):",id:"kotlin-java-solution-similar-to-it-but-much-longer",level:4},{value:"C# with Top-level statements and Global usings features:",id:"c-with-top-level-statements-and-global-usings-features",level:4},{value:"Or, as C# one-liner:",id:"or-as-c-one-liner",level:4},{value:"Why manual parsing is a disadvantage?",id:"why-manual-parsing-is-a-disadvantage",level:2},{value:"Flexibility to format changes",id:"flexibility-to-format-changes",level:3},{value:"Mental complexity",id:"mental-complexity",level:3},{value:"Performance",id:"performance",level:3},{value:"Underestimation of this flaw",id:"underestimation-of-this-flaw",level:2},{value:"What to do with it?",id:"what-to-do-with-it",level:2},{value:"Announce",id:"announce",level:2}],u={toc:p};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In competitive programming ",(0,i.kt)("a",{parentName:"p",href:"https://codeforces.com"},"contests"),", interviews, or when solving problems from ",(0,i.kt)("a",{parentName:"p",href:"https://timus.online/?locale=en"},"archives")," for learning we are facing automatic judging systems. These systems accept code on some supported language, then compile and run it against many test cases."),(0,i.kt)("p",null,"Although modern versions of C# are usually supported on these systems, I prefer to use C++, Java, or Kotlin for solving algorithmic problems. Why? Because judging systems provide test cases as plain text to STDIN and C# doesn't have a good way to read and parse it."),(0,i.kt)("h2",{id:"the-flaw"},"The Flaw"),(0,i.kt)("p",null,"Let's look at example. It is ",(0,i.kt)("a",{parentName:"p",href:"https://timus.online/problem.aspx?space=1&num=1000&locale=en"},'"A+B problem"'),", demo problem used to get familiar with judging system."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plain"},"Statement:\nCalculate A + B (|A|, |B| <= 10^5)\n\nInput:\nThe single line contains two integers, A and B, separated by one space\n\nOutput:\nA+B value\n\nNotes:\nUse + operator\n")),(0,i.kt)("p",null,"It's simple, isn't it?"),(0,i.kt)("p",null,"Let's compare solutions for this problem in different programming languages."),(0,i.kt)("h4",{id:"c"},"C:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n\nint main()\n{\n    int a, b;\n    scanf("%d %d", &a, &b);\n    printf("%d", a + b);\n}\n')),(0,i.kt)("h4",{id:"c-1"},"C++:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c++"},"#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int a, b;\n    cin >> a >> b;\n    cout << a + b;\n}\n")),(0,i.kt)("h4",{id:"kotlin-java-solution-similar-to-it-but-much-longer"},"Kotlin (Java solution similar to it, but much longer):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kt"},"import java.util.*\n\nfun main() {\n    val sc = Scanner(System.`in`)\n    val a = sc.nextInt()\n    val b = sc.nextInt()\n    print(a + b)\n}\n")),(0,i.kt)("h4",{id:"c-with-top-level-statements-and-global-usings-features"},"C# with ",(0,i.kt)("a",{parentName:"h4",href:"https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/program-structure/top-level-statements"},"Top-level statements")," and ",(0,i.kt)("a",{parentName:"h4",href:"https://blog.jetbrains.com/dotnet/2021/11/18/global-usings-in-csharp-10/"},"Global usings")," features:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"var numbers = Console.ReadLine().Split();\nvar a = int.Parse(numbers[0]);\nvar b = int.Parse(numbers[1]);\nConsole.WriteLine(a + b);\n")),(0,i.kt)("h4",{id:"or-as-c-one-liner"},"Or, as C# one-liner:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"Console.WriteLine(Console.ReadLine().Split().Select(int.Parse).Sum());\n")),(0,i.kt)("p",null,"As we can see, C, C++, and Kotlin solutions just read two integers from the input. Instead, C# program should ",(0,i.kt)("inlineCode",{parentName:"p"},".ReadLine()")," the single line of the input, then ",(0,i.kt)("inlineCode",{parentName:"p"},".Split()")," it by whitespace character, then ",(0,i.kt)("inlineCode",{parentName:"p"},".Parse")," each part of the line to target type ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),"."),(0,i.kt)("p",null,"So, when many other languages allow taking the input as a sequence of tokens of the given types, in C# we are forced to take the input as a ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"char"),", then parse it manually. There's no simple abstraction that hides parsing complexity from a programmer in the .NET world."),(0,i.kt)("p",null,"I prefer the C++ solution for this problem because the code in the ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," method is way shorter than others, only 32 characters without unnecessary whitespaces, and also clear to read. C# one-liner has 70 characters in total. For real, non-demo problems, C++ often is much harder to debug."),(0,i.kt)("h2",{id:"why-manual-parsing-is-a-disadvantage"},"Why manual parsing is a disadvantage?"),(0,i.kt)("h3",{id:"flexibility-to-format-changes"},"Flexibility to format changes"),(0,i.kt)("p",null,'Let\'s go back to "A+B problem" and change the input format slightly.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"Input:\n- A single line contains two integers, A and B, separated by one space\n+ A two lines, each line containing one integer\n")),(0,i.kt)("p",null,"C, C++, and Kotlin solutions remain unchanged. But the C# solution needs to be rewritten to support the new input format."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"Console.WriteLine(int.Parse(Console.ReadLine()) + int.Parse(Console.ReadLine()));\n")),(0,i.kt)("p",null,"In this simple case, it is possible to write a C# solution that supports both input formats via the ",(0,i.kt)("inlineCode",{parentName:"p"},"Console.ReadToEnd()")," method, but it is inconvenient when the input is more complex."),(0,i.kt)("h3",{id:"mental-complexity"},"Mental complexity"),(0,i.kt)("p",null,"When solving algorithmic problems you want to focus on an algorithm, and the correctness of the implementation, but not on the input formats, line endings, duplicated or invisible Unicode ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Whitespace_character"},"whitespace characters"),", and other quirks. It's much less painful when it is handled by a bunch of prewritten code, ideally from the standard library."),(0,i.kt)("p",null,"Also, in programming contests, you want to save time, because the speed of problem-solving affects the final score."),(0,i.kt)("h3",{id:"performance"},"Performance"),(0,i.kt)("p",null,"Obviously, if we write ",(0,i.kt)("inlineCode",{parentName:"p"},"int.Parse(Console.ReadLine())"),", an intermediate ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," object will be allocated. This allocation takes some time and memory. Then if the garbage collector will be triggered, it will also take some time to process and clean up this object."),(0,i.kt)("p",null,"If the line contains more than one integer, an intermediate ",(0,i.kt)("inlineCode",{parentName:"p"},"int[]")," array will be allocated in the ",(0,i.kt)("inlineCode",{parentName:"p"},".Split()")," method, with the same consequences."),(0,i.kt)("p",null,"There are also other performance problems with plain text IO, which are discussed in the ",(0,i.kt)("em",{parentName:"p"},"next")," post."),(0,i.kt)("h2",{id:"underestimation-of-this-flaw"},"Underestimation of this flaw"),(0,i.kt)("p",null,"This disadvantage isn't dedicated to C# and other .NET languages. E.g. Python and Rust use the same approach for the plain text input reading. And it is not a disadvantage that we are facing in day-to-day work as software developers, because in production cases plain text input is very rare in comparison with JSON or other structured data formats."),(0,i.kt)("p",null,"For console applications, ",(0,i.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/dotnet/standard/commandline/"},"System.CommandLine")," or another argument/input parsing library could be used instead. But judging systems limits us to standard library features and standardized plain text input format. And it's impossible to just install some fancy NuGet package in these systems."),(0,i.kt)("p",null,"But why is this important at all?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Solving algorithmic problems and participating in programming contests are great ways to learn new things and improve your programming skills. The ability to flawlessly use familiar programming language greatly simplifies it, especially for beginners."),(0,i.kt)("li",{parentName:"ul"},"This feature could help to promote the language among developers as a tool for solving algorithmic problems on automatic judging systems."),(0,i.kt)("li",{parentName:"ul"},"For newbies who learn programming during solving algorithmic problems, this will help to choose C# and .NET instead of another language and platform.")),(0,i.kt)("h2",{id:"what-to-do-with-it"},"What to do with it?"),(0,i.kt)("p",null,"There is already ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/dotnet/runtime/issues/64621"},".NET API Proposal")," that describes this issue. This proposal is far from well-written but contains a discussion about the usefulness of this feature and design decisions. Most likely, if this feature will be implemented, it will look like Java ",(0,i.kt)("inlineCode",{parentName:"p"},"Scanner")," class."),(0,i.kt)("p",null,"If you also find this feature useful \u2014 please upvote the GitHub issue!"),(0,i.kt)("h2",{id:"announce"},"Announce"),(0,i.kt)("p",null,"In the next posts we will discuss:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A performance problems with plain text IO"),(0,i.kt)("li",{parentName:"ul"},"Efficient plain text input reading implementation")))}m.isMDXComponent=!0}}]);