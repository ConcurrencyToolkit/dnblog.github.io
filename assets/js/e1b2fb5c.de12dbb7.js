"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[169],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>k});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=p(n),c=r,k=d["".concat(s,".").concat(c)]||d[c]||m[c]||i;return n?a.createElement(k,l(l({ref:t},u),{},{components:n})):a.createElement(k,l({ref:t},u))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[d]="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},6402:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={slug:"plain-text-io-lib",title:"Text IO Library",tags:["text_io"]},l=void 0,o={permalink:"/plain-text-io-lib",source:"@site/blog/2022-12-07-plain-text-io-library.mdx",title:"Text IO Library",description:"Although the previous post revealed that .NET IO performance is not unsatisfactory,",date:"2022-12-07T00:00:00.000Z",formattedDate:"December 7, 2022",tags:[{label:"text_io",permalink:"/tags/text-io"}],readingTime:21.375,hasTruncateMarker:!0,authors:[],frontMatter:{slug:"plain-text-io-lib",title:"Text IO Library",tags:["text_io"]},nextItem:{title:"Text IO Benchmarks",permalink:"/text-io-benchmarks"}},s={authorsImageUrls:[]},p=[{value:"Design",id:"design",level:2},{value:"Encoding",id:"encoding",level:3},{value:"Parsing",id:"parsing",level:3},{value:"ASCII",id:"ascii",level:4},{value:"UTF-16",id:"utf-16",level:4},{value:"Buffering",id:"buffering",level:3},{value:"API",id:"api",level:3},{value:"TextScanner",id:"textscanner",level:2},{value:"Interface",id:"interface",level:3},{value:"Usage sample",id:"usage-sample",level:3},{value:"TryRead",id:"tryread",level:3},{value:"GetNextToken",id:"getnexttoken",level:3},{value:"Char &amp; String",id:"char--string",level:3},{value:"Delimiter handling",id:"delimiter-handling",level:3},{value:"Performance",id:"performance",level:3},{value:"AsciiScanner",id:"asciiscanner",level:2},{value:"Interface",id:"interface-1",level:3},{value:"Usage sample",id:"usage-sample-1",level:3},{value:"Avoiding code duplication",id:"avoiding-code-duplication",level:3},{value:"TryRead",id:"tryread-1",level:3},{value:"Token based approach",id:"token-based-approach",level:3},{value:"Scanning approach",id:"scanning-approach",level:3},{value:"Implementation",id:"implementation",level:3},{value:"UTF-8 support",id:"utf-8-support",level:3},{value:"Performance",id:"performance-1",level:3},{value:"Reading from MemoryStream:",id:"reading-from-memorystream",level:4},{value:"Reading from Console:",id:"reading-from-console",level:4},{value:"Reduced AsciiScanner",id:"reduced-asciiscanner",level:2},{value:"Announce",id:"announce",level:2},{value:"Links",id:"links",level:2},{value:"Homework",id:"homework",level:2}],u={toc:p};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Although the ",(0,r.kt)("a",{parentName:"p",href:"/text-io-benchmarks"},"previous post")," revealed that .NET IO performance is not unsatisfactory,\nit remains ",(0,r.kt)("a",{parentName:"p",href:"/text-io-flaw"},"inconvenient"),", particularly  for input reading."),(0,r.kt)("p",null,"In this article, I design and implement a high-performance AOT-friendly input parsing library to replace ",(0,r.kt)("inlineCode",{parentName:"p"},"int.Parse(Console.Readline())")," with something like ",(0,r.kt)("inlineCode",{parentName:"p"},"sc.ReadInt()"),"."),(0,r.kt)("p",null,"Furthermore, I give you this ",(0,r.kt)("a",{parentName:"p",href:"https://www.nuget.org/packages/Epeshk.Text"},"library")," as a concise code snippet that can be easily copied into your program and utilized on online judging systems."),(0,r.kt)("h2",{id:"design"},"Design"),(0,r.kt)("h3",{id:"encoding"},"Encoding"),(0,r.kt)("p",null,"The primary encoding in the .NET is UTF-16, a 2-byte wide character encoding."),(0,r.kt)("p",null,"However, most programming contest problems use much simpler 1-byte wide ASCII input."),(0,r.kt)("p",null,"Therefore, input parsing with string conversion requires data re-encoding, which can negatively impact performance. And it is good for performance to avoid this conversions."),(0,r.kt)("p",null,"I decided to implement three different Scanners for input:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"TextScanner")," - a reader which works with the .NET ",(0,r.kt)("inlineCode",{parentName:"li"},"TextReader")," abstraction, reading ",(0,r.kt)("inlineCode",{parentName:"li"},"char"),"s rather than raw bytes."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"AsciiScanner")," - a reader for ASCII encoding that operates over a byte ",(0,r.kt)("inlineCode",{parentName:"li"},"Stream")),(0,r.kt)("li",{parentName:"ul"},"other ",(0,r.kt)("inlineCode",{parentName:"li"},"AsciiScanner")," - a minified version of the ",(0,r.kt)("inlineCode",{parentName:"li"},"AsciiScanner"),", shortened for use in single-file programs")),(0,r.kt)("h3",{id:"parsing"},"Parsing"),(0,r.kt)("h4",{id:"ascii"},"ASCII"),(0,r.kt)("p",null,".NET already provides an amount of fast APIs for primitive types parsing and we could just use them, saving a lot of time and code size."),(0,r.kt)("p",null,"ASCII parser already included in .NET for the ",(0,r.kt)("inlineCode",{parentName:"p"},"System.Text.Json")," purposes.\nIt is ",(0,r.kt)("inlineCode",{parentName:"p"},"Utf8Parser")," class with static methods for parsing numeric and some other types, like ",(0,r.kt)("inlineCode",{parentName:"p"},"TimeSpan")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"DateTime")," from ",(0,r.kt)("inlineCode",{parentName:"p"},"Span<byte>"),"."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Don't be tricked by naming, in fact, ",(0,r.kt)("inlineCode",{parentName:"p"},"Utf8Parser")," is just an ASCII parser:"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"It is a low-level thing which couldn't handle all Unicode ",(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Numerals_in_Unicode"},"numeral characters"),"."),(0,r.kt)("li",{parentName:"ul"},"It is named ",(0,r.kt)("inlineCode",{parentName:"li"},"Utf8")," just by use-case, which is extracting plain-text data from UTF-8 data chunks."))),(0,r.kt)("p",null,"Let's look at typical ",(0,r.kt)("inlineCode",{parentName:"p"},"Utf8Parser")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"static class Utf8Parser\n{\n  static bool TryParse(\n    ReadOnlySpan<byte> source,\n    out TYPE result,\n    out int bytesConsumed,\n    char format='\\0');\n\n  /* methods for other TYPEs */\n}\n")),(0,r.kt)("p",null,"As we can see, ",(0,r.kt)("inlineCode",{parentName:"p"},"Utf8Parser")," methods can parse values with ",(0,r.kt)("em",{parentName:"p"},"scanning")," behavior, consuming only some bytes from the Span, without knowing where the data ends. It allows to ",(0,r.kt)("em",{parentName:"p"},"scan")," data straightforward, without lookahead for the next separator."),(0,r.kt)("h4",{id:"utf-16"},"UTF-16"),(0,r.kt)("p",null,"UTF-16 can be parsed via methods like ",(0,r.kt)("inlineCode",{parentName:"p"},"int.TryParse(ReadOnlySpan<char>, IFormatProvider)"),".\nSince .NET 7, these methods also accessible from ",(0,r.kt)("inlineCode",{parentName:"p"},"ISpanParsable<TSelf>")," generic math interface. Let's look at it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public interface ISpanParsable<TSelf> : IParsable<TSelf>\n  where TSelf : ISpanParsable<TSelf>?\n{\n  static abstract bool TryParse(\n    ReadOnlySpan<char> s,\n    IFormatProvider? provider,\n    out TSelf result);\n\n  static abstract TSelf Parse(\n    ReadOnlySpan<char> s,\n    IFormatProvider? provider);\n}\n")),(0,r.kt)("p",null,"These methods will return ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," if any other data except value contains in the Span. So, ",(0,r.kt)("inlineCode",{parentName:"p"},"TextScanner")," will not support ",(0,r.kt)("em",{parentName:"p"},"scanning")," behavior, it will read the data twice: lookahead for delimiter and parse itself."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},'The buffer contains the text "123 456"'),(0,r.kt)("p",{parentName:"admonition"},"If the parser support ",(0,r.kt)("em",{parentName:"p"},"scanning"),", it will return ",(0,r.kt)("inlineCode",{parentName:"p"},"123")," as parsed value and ",(0,r.kt)("inlineCode",{parentName:"p"},"3")," as consumed bytes. So it is possible to build lookahead-free input reading over it."),(0,r.kt)("p",{parentName:"admonition"},"And if isn't, it will return ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," or throw. So, the caller code should lookahead for whitespace after ",(0,r.kt)("inlineCode",{parentName:"p"},"123"),".")),(0,r.kt)("h3",{id:"buffering"},"Buffering"),(0,r.kt)("p",null,"To use ",(0,r.kt)("inlineCode",{parentName:"p"},"ISpanParsable<TSelf>")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Utf8Parser")," methods, data should be provided as ",(0,r.kt)("inlineCode",{parentName:"p"},"ReadOnlySpan<char>")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"ReadOnlySpan<byte>")," respectively."),(0,r.kt)("p",null,"So there is no need for some external buffering layer between ",(0,r.kt)("inlineCode",{parentName:"p"},"TextReader")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Stream")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Scanner"),", buffering will occur in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Scanner")," itself."),(0,r.kt)("p",null,"Required buffer size depends on underlying stream type. If the data already stored in memory, even a small buffer is enough.\nFor Console stream, especially on Linux, larger buffer (~16 KB) may give a noticeable performance gain."),(0,r.kt)("p",null,"However, we could not rely on the assumption that value always fits in the buffer, and should therefore support buffer growing to not be tricked by something like this:"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"this"),(0,r.kt)("p",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"0.000000000000000000000000000000000000000000000000000000000000000000000000000000\n00000000000000000000000000000000000000000000000000000000000000000000000000000000\n00000000000000000000000000000000000000000000000000000000000000000000000000000000\n00000000000000000000000000000000000000000000000000000000000000000000000000000000\n00000494065645841246544176568792868221372365059802614324764425585682500675507270\n20875186529983636163599237979656469544571773092665671035593979639877479601078187\n81263007131903114045278458171678489821036887186360569987307230500063874091535649\n84387312473397273169615140031715385398074126238565591171026658556686768187039560\n31062493194527159149245532930545654440112748012970999954193198940908041656332452\n47571478690147267801593552386115501348035264934720193790268107107491703332226844\n75333572083243193609238289345836806010601150616980975307834227731832924790498252\n47307763759272478746560847782037344696995336470179726777175851256605511991315048\n91101451037862738167250955837389733598993664809941164205702637090279242767544565\n22908753868250641971826553344726562500000000000000000000000000000000000000000000\n00000000000000000000000000000000000000000000000000000000000000000000000000000000\n[more zeroes]\n")))),(0,r.kt)("h3",{id:"api"},"API"),(0,r.kt)("p",null,"Because ",(0,r.kt)("inlineCode",{parentName:"p"},"AsciiScanner")," is based on ",(0,r.kt)("inlineCode",{parentName:"p"},"Utf8Parser"),", I decided to be consistent with ",(0,r.kt)("inlineCode",{parentName:"p"},"Utf8Parser")," methods."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"bool TryParse(out int value, char format='\\0');\nbool TryParse(out double value, char format='\\0');\n...\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Utf16Parser")," will consistent with ",(0,r.kt)("inlineCode",{parentName:"p"},"ISpanParsable<TSelf>")," methods."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"bool TryRead<T>(out T value)\nbool TryRead<T>(out T value, IFormatProvider formatProvider)\n")),(0,r.kt)("p",null,"Method without overload will use ",(0,r.kt)("inlineCode",{parentName:"p"},"InvariantCulture"),". Just because culture-dependency is basically useless for console input."),(0,r.kt)("h2",{id:"textscanner"},"TextScanner"),(0,r.kt)("h3",{id:"interface"},"Interface"),(0,r.kt)("p",null,"Let's begin with a simple ",(0,r.kt)("inlineCode",{parentName:"p"},"TextScanner"),". It will operate over ",(0,r.kt)("inlineCode",{parentName:"p"},"TextReader")," and read any data type that implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"ISpanParsable<TSelf>")," generic interface.\nGeneric math has some pros and cons, and constructing a Scanner is a good exercise for understanding them."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public class TextScanner\n{\n  private readonly TextReader reader;\n\n  public TextScanner(TextReader? reader=null) => this.reader = reader ?? new TextReader(Console.OpenStandardInput());\n\n  public bool TryRead<T>(out T value, IFormatProvider? formatProvider)\n    where T : ISpanParsable<T>\n    => throw new NotImplementedException();\n}\n")),(0,r.kt)("p",null,"There is only one method to handle all ",(0,r.kt)("inlineCode",{parentName:"p"},"ISpanParsable<TSelf>")," types! All other, like ",(0,r.kt)("inlineCode",{parentName:"p"},".Read<T>")," may be extensions. It ",(0,r.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/dotnet/api/system.ispanparsable-1?view=net-7.0"},"already supports")," all main numeric types from good old ",(0,r.kt)("inlineCode",{parentName:"p"},"int")," to brand new (for .NET) ",(0,r.kt)("inlineCode",{parentName:"p"},"Half"),". And it is possible to implement this interface for custom type."),(0,r.kt)("p",null,"But it's impossible to extend ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/dotnet/runtime/issues/78523"},"existing type")," like ",(0,r.kt)("inlineCode",{parentName:"p"},"bool")," with required methods (who says ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/rust-by-example/trait.html"},"traits"),"?). For this kind of extensibility, we may also introduce ",(0,r.kt)("inlineCode",{parentName:"p"},"ISpanParser<T>")," interface. I will use similar approach ",(0,r.kt)("a",{parentName:"p",href:"#avoiding-code-duplication"},"later")," for the ",(0,r.kt)("inlineCode",{parentName:"p"},"AsciiScanner"),", because there is no ",(0,r.kt)("inlineCode",{parentName:"p"},"IAsciiParsable")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"IUtf8Parsable")," interface."),(0,r.kt)("h3",{id:"usage-sample"},"Usage sample"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"var sc = new TextScanner();\n\nvar a = sc.Read<int>();\nvar b = sc.Read<int>();\n\nwhile (sc.TryRead(out double d))\n{\n}\n")),(0,r.kt)("p",null,"Yes, ",(0,r.kt)("inlineCode",{parentName:"p"},".Read<int>()")," may be hard to type, because explicit generic parameter syntax isn't well supported by code completion, but it's always possible to add an extension, e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},".ReadInt()"),", or even simpler: ",(0,r.kt)("inlineCode",{parentName:"p"},".Int()")),(0,r.kt)("h3",{id:"tryread"},"TryRead"),(0,r.kt)("p",null,"Now we need to implement ",(0,r.kt)("inlineCode",{parentName:"p"},"TryRead<T>(out T value, IFormatProvider)")," method. ",(0,r.kt)("inlineCode",{parentName:"p"},"ISpanParsable<TSelf>.TryParse")," accepts ",(0,r.kt)("inlineCode",{parentName:"p"},"ReadOnlySpan<char>")," for parsing. So, we need to use some ",(0,r.kt)("inlineCode",{parentName:"p"},"char[]")," buffer for ",(0,r.kt)("inlineCode",{parentName:"p"},"TextReader")," data."),(0,r.kt)("p",null,"So, logic of this method is pretty straightforward:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Do lookahead for the next token. Method which performs lookahead is also fetch the data."),(0,r.kt)("p",{parentName:"li"},"Token is a sequence of characters between separators, e.g. whitespaces). Line ",(0,r.kt)("inlineCode",{parentName:"p"},"123 456 789")," contains three tokens: ",(0,r.kt)("inlineCode",{parentName:"p"},"123"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"456"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"789"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Try parse this token with ",(0,r.kt)("inlineCode",{parentName:"p"},"T.TryParse")," method.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If parsing is successful, move offset in the internal buffer."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool TryRead<T>(out T value, IFormatProvider? formatProvider=null)\n  where T : ISpanParsable<T>\n{\n  ReadOnlySpan<char> span = GetNextToken();\n  if (!T.TryParse(span, formatProvider, out value))\n    return false;\n\n  Consume(span.Length);\n  return true;\n}\n\nprivate char[] buffer;\nprivate int length;\nprivate int offset;\n\nprivate void Consume(int bytes) => offset += bytes;\n")),(0,r.kt)("h3",{id:"getnexttoken"},"GetNextToken"),(0,r.kt)("p",null,"Now we need a core method of the TextScanner, ",(0,r.kt)("inlineCode",{parentName:"p"},"GetNextToken"),". For best performance, this function is divided to the fast and slow path."),(0,r.kt)("p",null,"Fast path is a short inlineable function which handles a case when the token fits in the buffer. Slow path is triggered when end of the buffer was reached, or when the buffer is too small for the next token."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"private ReadOnlySpan<char> GetNextToken()\n{\n  SkipDelimiters();\n\n  int end = FindDelimiter(offset);\n\n  if (end < length)\n    return buffer.AsSpan(offset, end - offset);\n\n  return GetNextTokenRare();\n}\n\nprivate void SkipDelimiters()\n{\n  while (offset < length && IsDelimiter(buffer[offset]))\n    offset++;\n}\n\nprivate int FindDelimiter(int end)\n{\n  while (end < length && !IsDelimiter(buffer[end]))\n    end++;\n  return end;\n}\n\n")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Slow path & Fetch data implementation"),(0,r.kt)("p",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"// clearly show our intention to make rare called code path\n[MethodImpl(MethodImplOptions.NoInlining)]\nprivate ReadOnlySpan<char> GetNextTokenRare()\n{\n  while (offset == length)\n  {\n    if (!FetchData())\n      return ReadOnlySpan<char>.Empty;\n\n    SkipDelimiters();\n  }\n\n  MoveDataToBufferStart();\n\n  int end = 0;\n\n  while (true)\n  {\n    end = FindDelimiter(end);\n\n    if (end < length)\n      return buffer.AsSpan(0, end);\n\n    if (!FetchData())\n      return buffer.AsSpan(0, end);\n  }\n}\n\nprivate bool FetchData()\n{\n  MoveDataToBufferStart();\n\n  if (length == buffer.Length)\n    GrowBuffer();\n\n  // read the data from TextReader right after remaining data\n  int count = reader.Read(buffer, length, buffer.Length - length);\n\n  // end of the data reached\n  if (count > 0)\n    length += count;\n\n  return count > 0;\n}\n\nprivate void MoveDataToBufferStart()\n{\n  // calculate the length of unused data span\n  int remaining = length - offset;\n\n  // shift unused data to the beginning\n  buffer.AsSpan(offset, remaining).CopyTo(buffer);\n  offset = 0;\n  length = remaining;\n}\n\nprivate void GrowBuffer()\n{\n  var newBuffer = new char[buffer.Length * 2];\n  buffer.CopyTo(newBuffer, 0);\n  buffer = newBuffer;\n}\n")))),(0,r.kt)("h3",{id:"char--string"},"Char & String"),(0,r.kt)("p",null,"In some contest problems, input was given as a matrix of the characters. E.g. this matrix represents ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Glider_(Conway%27s_Life)"},"glider")," from the ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life"},"Game of Life"),":"),(0,r.kt)("pre",null,"5 9",(0,r.kt)("br",null),"000000000",(0,r.kt)("br",null),"0000",(0,r.kt)("b",null,"1"),"0000",(0,r.kt)("br",null),"00000",(0,r.kt)("b",null,"1"),"000",(0,r.kt)("br",null),"000",(0,r.kt)("b",null,"111"),"000",(0,r.kt)("br",null),"000000000"),(0,r.kt)("p",null,"Some programmers used to parse inputs like this, char by char:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"int n = sc.Read<int>();\nint m = sc.Read<int>();\n\nchar[,] arr = new char[n, m];\n\nfor (int i = 0; i < n; ++i)\nfor (int j = 0; j < m; ++j)\n  arr[i, j] = sc.Read<char>();\n")),(0,r.kt)("p",null,"And this code will compiles with our Scanner. Because char implements ",(0,r.kt)("inlineCode",{parentName:"p"},"ISpanParsable<TSelf>"),". But our current implementation of the TextScanner parses tokens between delimiters, so it will try to parse whole line as single character."),(0,r.kt)("p",null,"So, we need to add type-specific parts for this case in our code. Luckily, it will not hit performance, because compilers may eliminate conditions like ",(0,r.kt)("inlineCode",{parentName:"p"},"typeof(T) == typeof(char)")," during generic specification."),(0,r.kt)("p",null,"Note that ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," isn't ",(0,r.kt)("inlineCode",{parentName:"p"},"ISpanParsable<TSelf>"),", so it is useful to support string reading:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"int n = sc.Read<int>();\nint m = sc.Read<int>();\n\nstring[] arr = new string[n];\n\nfor (int i = 0; i < n; ++i)\n  arr[i] = sc.ReadToken();\n")),(0,r.kt)("p",null,"As you remember, we already implemented ",(0,r.kt)("inlineCode",{parentName:"p"},"ReadToken"),", now just create overload which copies data from buffer-backed ",(0,r.kt)("inlineCode",{parentName:"p"},"ReadOnlySpan")," to the new ",(0,r.kt)("inlineCode",{parentName:"p"},"string")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"  public bool TryReadString(out string value)\n  {\n    value = GetNextToken().ToString();\n    Consume(value.Length);\n    return value.Length > 0;\n  }\n")),(0,r.kt)("h3",{id:"delimiter-handling"},"Delimiter handling"),(0,r.kt)("p",null,"The only remaining method is ",(0,r.kt)("inlineCode",{parentName:"p"},"IsDelimiter"),"."),(0,r.kt)("p",null,"It is a hot path in ",(0,r.kt)("inlineCode",{parentName:"p"},"TextScanner")," code, as it is called for every character of the input. As such, supporting custom delimiters requires additional research on usability and performance. ",(0,r.kt)("inlineCode",{parentName:"p"},"char.IsWhitespace")," check is enough for programming contest's problems. However, other delimiters useful to support parsing of CSV files and markdown tables."),(0,r.kt)("p",null,"Note that it is not worth to optimize ",(0,r.kt)("inlineCode",{parentName:"p"},"IsDelimiter")," method for fast skipping of many delimiters. In most cases, delimiter is just a single space or line break."),(0,r.kt)("h3",{id:"performance"},"Performance"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Benchmark code"),(0,r.kt)("p",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[Benchmark]\npublic void Scanner()\n{\n  using var sr = new StringReader(input);\n  using var scanner = new TextScanner(sr);\n\n  while (scanner.TryRead(out int _)) ;\n}\n\n[Benchmark]\npublic void ReadInt_ReadLine()\n{\n  using var sr = new StringReader(input);\n\n  while (true)\n  {\n    var line = ms.ReadLine();\n    if (line == null) break;\n\n    foreach (var s in line.Split())\n    {\n      int.Parse(s);\n    }\n  }\n}\n")))),(0,r.kt)("p",null,"1M integers, written in the single line:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"|           Method |     Mean |      Gen0 |      Gen1 |      Gen2 |   Allocated |\n|----------------- |---------:|----------:|----------:|----------:|------------:|\n|          ReadInt | 23.48 ms |         - |         - |         - |     1.12 KB |\n| ReadInt_ReadLine | 90.97 ms | 3833.3333 | 3666.6667 | 1166.6667 | 53525.25 KB |\n\n")),(0,r.kt)("p",null,"1M integers, written in 4 columns and 250K lines:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"|           Method |      Gen0 |  Allocated |\n|----------------- |----------:|-----------:|\n|          ReadInt |         - |    1.12 KB |\n| ReadInt_ReadLine | 5307.6923 | 86968.2 KB |\n")),(0,r.kt)("p",null,"With the real ",(0,r.kt)("inlineCode",{parentName:"p"},"Console")," stream, this implementation work with additional 2ms overhead over ",(0,r.kt)("inlineCode",{parentName:"p"},"fastscan"),"."),(0,r.kt)("h2",{id:"asciiscanner"},"AsciiScanner"),(0,r.kt)("h3",{id:"interface-1"},"Interface"),(0,r.kt)("p",null,"For more impressive performance gains we need to get rid of character encoding conversion.\n",(0,r.kt)("inlineCode",{parentName:"p"},"AsciiScanner")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Utf8Scanner")," will operate over bytes ",(0,r.kt)("inlineCode",{parentName:"p"},"Stream")," in ASCII or UTF-8 encoding and read any data type that ",(0,r.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/dotnet/api/system.buffers.text.utf8parser?view=net-7.0"},"supported")," by the ",(0,r.kt)("inlineCode",{parentName:"p"},"Utf8Parser")," class."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public class AsciiScanner : IDisposable\n{\n  private readonly Stream stream;\n\n  public AsciiScanner(Stream stream=null) => this.stream = stream ?? Console.OpenStandardInput();\n\n  public bool TryReadInt32(out T value, char format='\\0') { ... }\n  public bool TryReadInt64(out T value, char format='\\0') { ... }\n  public bool TryReadDouble(out T value, char format='\\0') { ... }\n  ...\n\n  public bool Dispose() => stream.Dispose();\n}\n\npublic static class AsciiScannerExtensions\n{\n  public static bool ReadInt32(this AsciiScanner sc, char format='\\0');\n  public static bool ReadInt64(this AsciiScanner sc, char format='\\0');\n  public static bool ReadDouble(this AsciiScanner sc, char format='\\0');\n  ...\n}\n")),(0,r.kt)("p",null,"I use long ",(0,r.kt)("inlineCode",{parentName:"p"},"ReadIntXX")," names due to the ",(0,r.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/general-naming-conventions#avoiding-language-specific-names"},"design guideline")," about generic CLR type names."),(0,r.kt)("h3",{id:"usage-sample-1"},"Usage sample"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"var sc = new AsciiScanner();\n\nvar a = sc.ReadInt32();\nvar b = sc.ReadInt32();\n\nwhile (sc.TryReadDouble(out var d))\n{\n}\n")),(0,r.kt)("p",null,"Anyway, ",(0,r.kt)("inlineCode",{parentName:"p"},".ReadInt32()")," is easier to type than ",(0,r.kt)("inlineCode",{parentName:"p"},".Read<int>()")," and also has great completion support."),(0,r.kt)("h3",{id:"avoiding-code-duplication"},"Avoiding code duplication"),(0,r.kt)("p",null,"Because there is no ",(0,r.kt)("inlineCode",{parentName:"p"},"Utf8Parsable")," interface, and we should use a set of static methods for parsing, straightforward implementation for all the types will lead to code duplication. To avoid this, let's introduce interface for this purpose! Not ",(0,r.kt)("inlineCode",{parentName:"p"},"IUtf8Parsable"),", but ",(0,r.kt)("inlineCode",{parentName:"p"},"IUtf8Parser")," (or just, ",(0,r.kt)("inlineCode",{parentName:"p"},"IParser"),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"interface IParser<T>\n{\n  bool TryParse(\n    ReadOnlySpan<byte> source,\n    out T value,\n    out int bytesConsumed,\n    char standardFormat = default);\n}\n")),(0,r.kt)("p",null,"Now ",(0,r.kt)("inlineCode",{parentName:"p"},"AsciiScanner")," can be rewritten with generic core method. ",(0,r.kt)("inlineCode",{parentName:"p"},"TParser")," constrained to value types for generic specification: compiler will statically generate code for each type avoiding costs of generic call."),(0,r.kt)("p",null,"Because it is too boring and unmaintainable to write all ",(0,r.kt)("inlineCode",{parentName:"p"},"IParser")," implementations manually, I used source generation for this purpose. This approach may also be used to backport ",(0,r.kt)("inlineCode",{parentName:"p"},"TextScanner")," to older versions of .NET without generic math."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public class AsciiScanner : IDisposable\n{\n  ...\n  public bool TryRead(out T value, char format='\\0')\n    => TryRead<int, Int32Parser>(out value, format);\n  public bool TryRead(out T value, char format='\\0')\n    => TryRead<long, Int64Parser>(out value, format);\n  public bool TryRead(out T value, char format='\\0')\n    => TryRead<double, DoubleParser>(out value, format);\n  ...\n\n  private bool TryRead<T, TParser> TryRead(\n    out T value, char format='\\0', TParser parser=default)\n    where TParser : struct, IParser<T>\n    => throw new NotImplementedException();\n\n  public bool Dispose() => stream.Dispose();\n}\n")),(0,r.kt)("h3",{id:"tryread-1"},"TryRead"),(0,r.kt)("p",null,"Because ",(0,r.kt)("inlineCode",{parentName:"p"},"Utf8Parser")," methods allow scanning behavior, ",(0,r.kt)("inlineCode",{parentName:"p"},"TryRead")," can be implemented in two ways:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"like ",(0,r.kt)("inlineCode",{parentName:"li"},"TextScanner"),": read token between delimiters, then parse it."),(0,r.kt)("li",{parentName:"ul"},"without lookahead: try parse token, then update buffer if needed and retry")),(0,r.kt)("h3",{id:"token-based-approach"},"Token based approach"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"private bool TryRead<T, TParser>(out T value, char format='\\0', TParser parser=default)\n  where TParser : struct, IParser<T>\n{\n  ReadOnlySpan<byte> span = GetNextToken();\n  if (!parser.TryParse(span, out value, out int bytesConsumed, format))\n    return false;\n\n  Consume(bytesConsumed);\n  return true;\n}\n")),(0,r.kt)("p",null,"This approach with simplified delimiter handling (only 1-byte whitespaces) could be implemented mostly by replacing ",(0,r.kt)("inlineCode",{parentName:"p"},"char")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"byte")," in the previous ",(0,r.kt)("inlineCode",{parentName:"p"},"TextScanner")," code. So, it is easy to estimate it's performance."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Method"),(0,r.kt)("th",{parentName:"tr",align:"right"},"Mean"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ReadInt"),(0,r.kt)("td",{parentName:"tr",align:"right"},"23.65 ms")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AsciiReadInt"),(0,r.kt)("td",{parentName:"tr",align:"right"},"17.90 ms")))),(0,r.kt)("p",null,"Not impressive at all, right? So, we need to go with a scanning approach."),(0,r.kt)("h3",{id:"scanning-approach"},"Scanning approach"),(0,r.kt)("p",null,"Code for the scanning much more complex than for reading by tokens. The main problem is incomplete values on the end of the buffer."),(0,r.kt)("p",null,"Since ",(0,r.kt)("inlineCode",{parentName:"p"},"AsciiScanner/Utf8Scanner")," read stream by blocks and tokens are not prepared, it could end up with parsing a torn value. For example, value ",(0,r.kt)("inlineCode",{parentName:"p"},"123456")," could be fetched into buffer by two separate reads as: ",(0,r.kt)("inlineCode",{parentName:"p"},"[... 1234][56 ...]"),". And value ",(0,r.kt)("inlineCode",{parentName:"p"},"1234")," would be parsed by ",(0,r.kt)("inlineCode",{parentName:"p"},"Utf8Parser")," because it is a valid integer."),(0,r.kt)("p",null,"To avoid this false-positives, any successful value read from the end of the buffer should be retried if more data available in the stream."),(0,r.kt)("p",null,"For other kind of incomplete values ",(0,r.kt)("inlineCode",{parentName:"p"},"Utf8Parser")," will return false and report zero bytes consumed. It is something like ",(0,r.kt)("inlineCode",{parentName:"p"},"1e9")," value fetched as ","[... 1e][9 ..]",". Unfortunatelly, ",(0,r.kt)("inlineCode",{parentName:"p"},"Utf8Parser.Parse")," methods can't tell if it is invalid value, or just more data required."),(0,r.kt)("p",null,"So, I'm using some heuristics to determine if the failed read is real one and not caused by a torn value:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If we close to end of the buffer, retry with more data when possible."),(0,r.kt)("p",{parentName:"li"},"It helps against ",(0,r.kt)("inlineCode",{parentName:"p"},"[ ..tr][ue.. ]")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"[.. -][1 ..]"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"some of this limits can be found in dotnet ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/dotnet/runtime/blob/38ca26b27b9e7a867e6ff69eec3cabbfb4e9e1cf/src/libraries/System.Private.CoreLib/src/System/Number.NumberBuffer.cs#L13"},"sources")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bool")," has maximum 5 characters"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(u)long")," has maximum 20 characters"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"decimal")," has maximum 40 characters"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(U)Int128")," has maximum 40 characters"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Guid")," has maximum 38 characters in the ",(0,r.kt)("inlineCode",{parentName:"li"},"{nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn}")," form"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Floating point values are unbounded, so we can't rely on length alone. I tried to use other heuristic:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Still retry if the length are less than 10 bytes (for ",(0,r.kt)("inlineCode",{parentName:"li"},"NaN")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"-Infinity"),")"),(0,r.kt)("li",{parentName:"ul"},"Retry if the last byte in the buffer in ",(0,r.kt)("inlineCode",{parentName:"li"},"eE+-.,:/TZ")," to avoid split in ",(0,r.kt)("inlineCode",{parentName:"li"},"1234567890e-2")," and Date/Time types"),(0,r.kt)("li",{parentName:"ul"},"Maybe there are other cases which should be handled")))),(0,r.kt)("h3",{id:"implementation"},"Implementation"),(0,r.kt)("p",null,"It is good for performance to make the most frequently path short, inlineable and highly optimized.\nThe approach of separating hot and cold code also allows not to worry too much about performance of the cold (rare) parts."),(0,r.kt)("p",null,"Let's decide which paths in the ",(0,r.kt)("inlineCode",{parentName:"p"},"AsciiScanner")," should be considered hot:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"value fits in the buffer"),(0,r.kt)("li",{parentName:"ul"},"reads are successful")),(0,r.kt)("p",null,"Methods with ",(0,r.kt)("inlineCode",{parentName:"p"},"Rare")," suffix handle cold cases:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"loading data from stream into the buffer"),(0,r.kt)("li",{parentName:"ul"},"multibyte delimiters in the ",(0,r.kt)("inlineCode",{parentName:"li"},"Utf8Scanner"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"private byte[] buffer;\nprivate int offset;\nprivate int length;\n\nprivate Span<byte> Fragment => buffer.AsSpan(offset, length - offset);\n\nprivate bool TryRead<T, TParser>(out T value, char format='\\0', TParser parser=default)\n  where TParser : struct, IParser<T>\n  => TryReadInBuffer(out value, format, parser) ??\n     TryReadRare(out value, format, parser);\n\nprivate bool? TryReadInBuffer<T, TParser>(out T value, char format='\\0', TParser parser=default)\n  where TParser : struct, IParser<T>\n{\n  value = default!;\n\n  if (!SkipDelimiters())\n    return null;\n\n  if (!parser.TryParse(Fragment, out value, out int bytesConsumed, format))\n    return IsReadIncomplete<T>() ? null : false;\n\n  if (offset + bytesConsumed >= length)\n    return null;\n\n  offset += bytesConsumed;\n  return true;\n}\n\nprivate bool SkipDelimiters()\n{\n  while (offset < length)\n  {\n    var ch = buffer[offset];\n    if (!IsAsciiDelimiter(ch))\n      return ch < 0xC0 || SkipDelimitersRare(); // for AsciiScanner just return true\n    offset++;\n  }\n\n  return false;\n}\n\nprivate static bool IsAsciiDelimiter(byte c)\n  => (byte)(c - 9) <= 5 || c == 32;\n\n// AsciiScanner\n// private static bool IsAsciiDelimiter(byte c)\n//  => c <= 32;\n")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Slow path"),(0,r.kt)("p",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[MethodImpl(MethodImplOptions.NoInlining)]\nprivate bool TryReadRare<T, TParser>(out T value, char format='\\0', TParser parser=default)\n  where TParser : struct, IParser<T>\n{\n  while (FetchData())\n  {\n    var readInBuffer = TryReadInBuffer(out value, format, parser);\n    if (readInBuffer.HasValue)\n      return readInBuffer.GetValueOrDefault();\n  }\n\n  var result = parser.TryParse(Fragment, out value, out var bc, format);\n  offset += bc;\n  return result;\n}\n\n// FetchData is similar to TextScanner\n\n")))),(0,r.kt)("h3",{id:"utf-8-support"},"UTF-8 support"),(0,r.kt)("p",null,"For simple UTF-8 support ",(0,r.kt)("inlineCode",{parentName:"p"},"AsciiScanner")," may just skip all non-ASCII bytes. Anyway, ",(0,r.kt)("inlineCode",{parentName:"p"},"Utf8Parser")," parses only ASCII input."),(0,r.kt)("p",null,"To achieve full-featured UTF-8 support, ",(0,r.kt)("inlineCode",{parentName:"p"},"Rune")," type can be used since .NET Core 3.0. Unlike 16-bit ",(0,r.kt)("inlineCode",{parentName:"p"},"char"),", 32-bit ",(0,r.kt)("inlineCode",{parentName:"p"},"Rune")," type represents any Unicode codepoint."),(0,r.kt)("p",null,"Some operations, like whitespace skipping also may be reimplemented without using the ",(0,r.kt)("inlineCode",{parentName:"p"},"Rune")," type for additional performance, but I'm not sure that it is worth it, especially in the blog post code."),(0,r.kt)("p",null,"For character and string reading, ",(0,r.kt)("inlineCode",{parentName:"p"},"IParser<char>"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"IParser<Rune>"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"IParser<string>")," may be implemented."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"SkipDelimitersRare with `Rune` type"),(0,r.kt)("p",null,(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[MethodImpl(MethodImplOptions.NoInlining)]\nprivate bool SkipDelimitersRare()\n{\n  while (offset < length)\n  {\n    var val = buffer[offset];\n\n    if (IsAsciiDelimiter(val))\n    {\n      offset++;\n      continue;\n    }\n\n    var status = Rune.DecodeFromUtf8(Fragment, out Rune rune, out int bytesConsumed);\n    if (status is not OperationStatus.Done)\n      return false;\n    if (!Rune.IsWhiteSpace(rune))\n      return true;\n    offset += bytesConsumed;\n  }\n\n  return false;\n}\n")))),(0,r.kt)("h3",{id:"performance-1"},"Performance"),(0,r.kt)("h4",{id:"reading-from-memorystream"},"Reading from MemoryStream:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Method"),(0,r.kt)("th",{parentName:"tr",align:"right"},"Mean"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TextScanner"),(0,r.kt)("td",{parentName:"tr",align:"right"},"23.51 ms")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Utf8Scanner"),(0,r.kt)("td",{parentName:"tr",align:"right"},"12.18 ms")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AsciiScanner"),(0,r.kt)("td",{parentName:"tr",align:"right"},"11.47 ms")))),(0,r.kt)("h4",{id:"reading-from-console"},"Reading from Console:"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Windows"),(0,r.kt)("p",null,(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Program"),(0,r.kt)("th",{parentName:"tr",align:null},"Lang"),(0,r.kt)("th",{parentName:"tr",align:null},"Compiler"),(0,r.kt)("th",{parentName:"tr",align:"right"},"Mean (Int)"),(0,r.kt)("th",{parentName:"tr",align:"right"},"Mean (Double)"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"AsciiScanner")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"C#")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"NativeAOT")),(0,r.kt)("td",{parentName:"tr",align:"right"},(0,r.kt)("strong",{parentName:"td"},"30 ms")),(0,r.kt)("td",{parentName:"tr",align:"right"},(0,r.kt)("strong",{parentName:"td"},"50 ms"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fastscan"),(0,r.kt)("td",{parentName:"tr",align:null},"C++"),(0,r.kt)("td",{parentName:"tr",align:null},"msvc64"),(0,r.kt)("td",{parentName:"tr",align:"right"},"34 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"-")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fastscan"),(0,r.kt)("td",{parentName:"tr",align:null},"C#"),(0,r.kt)("td",{parentName:"tr",align:null},"NativeAOT"),(0,r.kt)("td",{parentName:"tr",align:"right"},"36 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"-")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"TextScanner")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"C#")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"NativeAOT")),(0,r.kt)("td",{parentName:"tr",align:"right"},(0,r.kt)("strong",{parentName:"td"},"36 ms")),(0,r.kt)("td",{parentName:"tr",align:"right"},(0,r.kt)("strong",{parentName:"td"},"66 ms"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fastscan"),(0,r.kt)("td",{parentName:"tr",align:null},"C++"),(0,r.kt)("td",{parentName:"tr",align:null},"g++64"),(0,r.kt)("td",{parentName:"tr",align:"right"},"45 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"-")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"AsciiScanner")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"C#")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"JIT")),(0,r.kt)("td",{parentName:"tr",align:"right"},(0,r.kt)("strong",{parentName:"td"},"56 ms")),(0,r.kt)("td",{parentName:"tr",align:"right"},(0,r.kt)("strong",{parentName:"td"},"75 ms"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fastscan"),(0,r.kt)("td",{parentName:"tr",align:null},"C#"),(0,r.kt)("td",{parentName:"tr",align:null},"JIT"),(0,r.kt)("td",{parentName:"tr",align:"right"},"58 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"-")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"console"),(0,r.kt)("td",{parentName:"tr",align:null},"C#"),(0,r.kt)("td",{parentName:"tr",align:null},"NativeAOT"),(0,r.kt)("td",{parentName:"tr",align:"right"},"58 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"92 ms")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"TextScanner")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"C#")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"JIT")),(0,r.kt)("td",{parentName:"tr",align:"right"},(0,r.kt)("strong",{parentName:"td"},"64 ms")),(0,r.kt)("td",{parentName:"tr",align:"right"},(0,r.kt)("strong",{parentName:"td"},"92 ms"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cin_fast"),(0,r.kt)("td",{parentName:"tr",align:null},"C++"),(0,r.kt)("td",{parentName:"tr",align:null},"g++64"),(0,r.kt)("td",{parentName:"tr",align:"right"},"74 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"1650 ms")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"scanf"),(0,r.kt)("td",{parentName:"tr",align:null},"C++"),(0,r.kt)("td",{parentName:"tr",align:null},"msvc64"),(0,r.kt)("td",{parentName:"tr",align:"right"},"76 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"100 ms")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"console"),(0,r.kt)("td",{parentName:"tr",align:null},"C#"),(0,r.kt)("td",{parentName:"tr",align:null},"JIT"),(0,r.kt)("td",{parentName:"tr",align:"right"},"85 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"117 ms")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"token"),(0,r.kt)("td",{parentName:"tr",align:null},"Kt"),(0,r.kt)("td",{parentName:"tr",align:null},"JVM"),(0,r.kt)("td",{parentName:"tr",align:"right"},"121 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"121 ms")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"slowscan"),(0,r.kt)("td",{parentName:"tr",align:null},"C#"),(0,r.kt)("td",{parentName:"tr",align:null},"JIT"),(0,r.kt)("td",{parentName:"tr",align:"right"},"117 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"-")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"slowscan"),(0,r.kt)("td",{parentName:"tr",align:null},"C#"),(0,r.kt)("td",{parentName:"tr",align:null},"NativeAOT"),(0,r.kt)("td",{parentName:"tr",align:"right"},"121 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"-")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"scanf"),(0,r.kt)("td",{parentName:"tr",align:null},"C++"),(0,r.kt)("td",{parentName:"tr",align:null},"g++64"),(0,r.kt)("td",{parentName:"tr",align:"right"},"190 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"310 ms")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cin_fast"),(0,r.kt)("td",{parentName:"tr",align:null},"C++"),(0,r.kt)("td",{parentName:"tr",align:null},"msvc64"),(0,r.kt)("td",{parentName:"tr",align:"right"},"243 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"274 ms")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cin"),(0,r.kt)("td",{parentName:"tr",align:null},"C++"),(0,r.kt)("td",{parentName:"tr",align:null},"msvc64"),(0,r.kt)("td",{parentName:"tr",align:"right"},"271 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"300 ms")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cin"),(0,r.kt)("td",{parentName:"tr",align:null},"C++"),(0,r.kt)("td",{parentName:"tr",align:null},"g++64"),(0,r.kt)("td",{parentName:"tr",align:"right"},"424 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"2000 ms")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"scanner"),(0,r.kt)("td",{parentName:"tr",align:null},"Kt"),(0,r.kt)("td",{parentName:"tr",align:null},"JVM"),(0,r.kt)("td",{parentName:"tr",align:"right"},"485 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"2000 ms")))))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Linux"),(0,r.kt)("p",null,(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Program"),(0,r.kt)("th",{parentName:"tr",align:null},"Lang"),(0,r.kt)("th",{parentName:"tr",align:null},"Compiler"),(0,r.kt)("th",{parentName:"tr",align:"right"},"Mean (Int)"),(0,r.kt)("th",{parentName:"tr",align:"right"},"Mean (Double)"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fastscan"),(0,r.kt)("td",{parentName:"tr",align:null},"C++"),(0,r.kt)("td",{parentName:"tr",align:null},"g++64"),(0,r.kt)("td",{parentName:"tr",align:"right"},"14 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"-")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"AsciiScanner")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"C#")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"NativeAOT")),(0,r.kt)("td",{parentName:"tr",align:"right"},(0,r.kt)("strong",{parentName:"td"},"14 ms")),(0,r.kt)("td",{parentName:"tr",align:"right"},(0,r.kt)("strong",{parentName:"td"},"40 ms"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"fastscan"),(0,r.kt)("td",{parentName:"tr",align:null},"C#"),(0,r.kt)("td",{parentName:"tr",align:null},"NativeAOT"),(0,r.kt)("td",{parentName:"tr",align:"right"},"27 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"-")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"TextScanner")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"C#")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"NativeAOT")),(0,r.kt)("td",{parentName:"tr",align:"right"},(0,r.kt)("strong",{parentName:"td"},"26 ms")),(0,r.kt)("td",{parentName:"tr",align:"right"},(0,r.kt)("strong",{parentName:"td"},"74 ms"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cin_fast"),(0,r.kt)("td",{parentName:"tr",align:null},"C++"),(0,r.kt)("td",{parentName:"tr",align:null},"g++64"),(0,r.kt)("td",{parentName:"tr",align:"right"},"38 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"101 ms")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"scanf"),(0,r.kt)("td",{parentName:"tr",align:null},"C++"),(0,r.kt)("td",{parentName:"tr",align:null},"g++64"),(0,r.kt)("td",{parentName:"tr",align:"right"},"44 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"70 ms")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"console"),(0,r.kt)("td",{parentName:"tr",align:null},"C#"),(0,r.kt)("td",{parentName:"tr",align:null},"NativeAOT"),(0,r.kt)("td",{parentName:"tr",align:"right"},"64 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"117 ms")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"token"),(0,r.kt)("td",{parentName:"tr",align:null},"Kt"),(0,r.kt)("td",{parentName:"tr",align:null},"JVM"),(0,r.kt)("td",{parentName:"tr",align:"right"},"97 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"97 ms")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"AsciiScanner")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"C#")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"JIT")),(0,r.kt)("td",{parentName:"tr",align:"right"},(0,r.kt)("strong",{parentName:"td"},"106 ms")),(0,r.kt)("td",{parentName:"tr",align:"right"},(0,r.kt)("strong",{parentName:"td"},"140 ms"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"slowscan"),(0,r.kt)("td",{parentName:"tr",align:null},"C#"),(0,r.kt)("td",{parentName:"tr",align:null},"NativeAOT"),(0,r.kt)("td",{parentName:"tr",align:"right"},"125 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"-")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"cin"),(0,r.kt)("td",{parentName:"tr",align:null},"C++"),(0,r.kt)("td",{parentName:"tr",align:null},"g++64"),(0,r.kt)("td",{parentName:"tr",align:"right"},"150 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"220 ms")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"TextScanner")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"C#")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"JIT")),(0,r.kt)("td",{parentName:"tr",align:"right"},(0,r.kt)("strong",{parentName:"td"},"155 ms")),(0,r.kt)("td",{parentName:"tr",align:"right"},(0,r.kt)("strong",{parentName:"td"},"205 ms"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"console"),(0,r.kt)("td",{parentName:"tr",align:null},"C#"),(0,r.kt)("td",{parentName:"tr",align:null},"JIT"),(0,r.kt)("td",{parentName:"tr",align:"right"},"160 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"200 ms")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"slowscan"),(0,r.kt)("td",{parentName:"tr",align:null},"C#"),(0,r.kt)("td",{parentName:"tr",align:null},"JIT"),(0,r.kt)("td",{parentName:"tr",align:"right"},"230 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"-")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"scanner"),(0,r.kt)("td",{parentName:"tr",align:null},"Kt"),(0,r.kt)("td",{parentName:"tr",align:null},"JVM"),(0,r.kt)("td",{parentName:"tr",align:"right"},"500 ms"),(0,r.kt)("td",{parentName:"tr",align:"right"},"1080 ms")))))),(0,r.kt)("p",null,"Who want to say now that C# Console IO is slow and unsuitable for competitive programming?!"),(0,r.kt)("h2",{id:"reduced-asciiscanner"},"Reduced AsciiScanner"),(0,r.kt)("p",null,"The main purpose of the reduced version is usage in single-file programs, like solutions for contest's problems."),(0,r.kt)("p",null,"So, limitations for the reduced version are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"targeting netstandard2.0 or netcoreapp3.1 to be supported by the automatic judging systems like ",(0,r.kt)("a",{parentName:"li",href:"https://timus.online/"},"timus")," and ",(0,r.kt)("a",{parentName:"li",href:"https://codeforces.com"},"codeforces")),(0,r.kt)("li",{parentName:"ul"},"C# language version is 8"),(0,r.kt)("li",{parentName:"ul"},"source code must be easily embeddable to another program"),(0,r.kt)("li",{parentName:"ul"},"source code must be relatively short to save a space for useful code.")),(0,r.kt)("p",null,"And here it is! Just paste it to the end of your single-file program and enjoy new input."),(0,r.kt)("p",null,"This code is not as small as I wanted, but it is mostly due to definitions for each supported type. Core logic is around 2 KB. Yes, ",(0,r.kt)("inlineCode",{parentName:"p"},"TextScanner")," with generic math is shorter, but .NET 7 is not wide supported yet."),(0,r.kt)("p",null,"For shorteness, you may keep only the code for common types: ",(0,r.kt)("inlineCode",{parentName:"p"},"(u)int"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"(u)long"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"float"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"double"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"// ReSharper disable All\nnamespace Epeshk.Text\n{\n  using System;using System.IO;using System.Text;using M=System.Runtime.CompilerServices.MethodImplAttribute;\n  using O=System.Runtime.CompilerServices.MethodImplOptions;using S=System.ReadOnlySpan<byte>;\n  using U=System.Buffers.Text.Utf8Parser;using n=System.Int32;using b=System.Boolean;using c=System.Char;\n\n  class AsciiScanner{\n    const O I=O.AggressiveInlining;const O N=O.NoInlining;byte[] b;n l,o;readonly Stream s;\n    public AsciiScanner(Stream stream=null,n size=8192){s=stream??Console.OpenStandardInput();b=new byte[size];}\n    b X<T,TP>(out T v,c f='\\0',TP p=default)where TP:struct,G<T> =>A(out v,f,p)??W(out v,f,p);\n    b? A<T,TP>(out T v,c f='\\0',TP p=default)where TP:struct,G<T>{v=default;if(!E())return null;if\n    (!p.P(S,out v,out n b,f))return K<T>()?(b?)null:false;if(o+b>=l)return null;o+=b;return true;}\n    [M(I)]b W<T,TP>(out T v,c f='\\0',TP p=default)where TP:struct,G<T>{while(F()){var q=A(out v,f,p);if(q.HasValue)\n    return q.GetValueOrDefault();}var r=p.P(S,out v,out var bc,f);o+=bc;return r;}\n    Span<byte> S=>b.AsSpan(o,l-o);\n    b K<T>()=>typeof(T)==typeof(double)||typeof(T)==typeof(float)?K():S.Length<32;\n    [M(N)]b K(){var s=S;if (s.Length<10)return false;var c=s[^1];return c-'+'<='/'-'+'||(c&~32)is'E';}\n    b E(){while(o<l){if(!D(b[o]))return true;o++;}return false;}\n    b F(){R();if(l==b.Length)H();n c=s.Read(b,l,b.Length-l);if(c>0)l+=c;return c>0;}\n    void R(){n r=l-o;b.AsSpan(o,r).CopyTo(b);o=0;l=r;}\n    [M(I)]static b D(byte c)=>(byte)(c+128)<=160;\n    void H(){var c=new byte[b.Length*2];b.CopyTo(c,0);b=c;}\n    static void Q()=>throw new FormatException();\n    interface G<T>{b P(S s,out T v,out n c,c f);}\n    struct CharP:G<c>{public b P(S s,out c v,out n c,c f){if(s.IsEmpty){v=default; c=0;return false;}v=(c)s[0];c=1;return true;}}\n    struct StringP:G<string>{public b P(S s,out string v,out n c,c f){if(s.IsEmpty){v=default;c=0;return false;}\n    var sb=new StringBuilder();foreach(var b in s){if(D(b))break;sb.Append((c)b);}v=sb.ToString();c=v.Length;return true;}}\n    [M(I)]T Read<T,TP>(c f='\\0')where TP:struct,G<T>{if(!X<T,TP>(out T v, f))Q();return v;}\n\n    [M(I)]public b TryRead(out string value)=>X<string,StringP>(out value);\n    [M(I)]public string ReadString()=>Read<string,StringP>();\n    [M(I)]public b TryRead(out c value)=>X<c,CharP>(out value);\n    [M(I)]public c ReadChar()=>Read<c,CharP>();\n    struct BoolP:G<b>{[M(I)]public b P(S s,out b v,out n c,c f)=>U.TryParse(s,out v,out c,f);}\n    struct SByteP:G<sbyte>{[M(I)]public b P(S s,out sbyte v,out n c,c f)=>U.TryParse(s,out v,out c,f);}\n    struct ByteP:G<byte>{[M(I)]public b P(S s,out byte v,out n c,c f)=>U.TryParse(s,out v,out c,f);}\n    struct Int16P:G<short>{[M(I)]public b P(S s,out short v,out n c,c f)=>U.TryParse(s,out v,out c,f);}\n    struct UInt16P:G<ushort>{[M(I)]public b P(S s,out ushort v,out n c,c f)=>U.TryParse(s,out v,out c,f);}\n    struct Int32P:G<n>{[M(I)]public b P(S s,out n v,out n c,c f)=>U.TryParse(s,out v,out c,f);}\n    struct UInt32P:G<uint>{[M(I)]public b P(S s,out uint v,out n c,c f)=>U.TryParse(s,out v,out c,f);}\n    struct Int64P:G<long>{[M(I)]public b P(S s,out long v,out n c,c f)=>U.TryParse(s,out v,out c,f);}\n    struct UInt64P:G<ulong>{[M(I)]public b P(S s,out ulong v,out n c,c f)=>U.TryParse(s,out v,out c,f);}\n    struct SingleP:G<float>{[M(I)]public b P(S s,out float v,out n c,c f)=>U.TryParse(s,out v,out c,f);}\n    struct DoubleP:G<double>{[M(I)]public b P(S s,out double v,out n c,c f)=>U.TryParse(s,out v,out c,f);}\n    struct DecimalP:G<decimal>{[M(I)]public b P(S s,out decimal v,out n c,c f)=>U.TryParse(s,out v,out c,f);}\n    [M(I)]public b TryRead(out b value,c format='\\0')=>X<b,BoolP>(out value,format);\n    [M(I)]public b ReadBool(c format='\\0')=>Read<b,BoolP>(format);\n    [M(I)]public b TryRead(out sbyte value,c format='\\0')=>X<sbyte,SByteP>(out value,format);\n    [M(I)]public sbyte ReadSByte(c format='\\0')=>Read<sbyte,SByteP>(format);\n    [M(I)]public b TryRead(out byte value,c format='\\0')=>X<byte,ByteP>(out value,format);\n    [M(I)]public byte ReadByte(c format='\\0')=>Read<byte,ByteP>(format);\n    [M(I)]public b TryRead(out short value,c format='\\0')=>X<short,Int16P>(out value,format);\n    [M(I)]public short ReadInt16(c format='\\0')=>Read<short,Int16P>(format);\n    [M(I)]public b TryRead(out ushort value,c format='\\0')=>X<ushort,UInt16P>(out value,format);\n    [M(I)]public ushort ReadUInt16(c format='\\0')=>Read<ushort,UInt16P>(format);\n    [M(I)]public b TryRead(out n value,c format='\\0')=>X<n,Int32P>(out value,format);\n    [M(I)]public n ReadInt32(c format='\\0')=>Read<n,Int32P>(format);\n    [M(I)]public b TryRead(out uint value,c format='\\0')=>X<uint,UInt32P>(out value,format);\n    [M(I)]public uint ReadUInt32(c format='\\0')=>Read<uint,UInt32P>(format);\n    [M(I)]public b TryRead(out long value,c format='\\0')=>X<long,Int64P>(out value,format);\n    [M(I)]public long ReadInt64(c format='\\0')=>Read<long,Int64P>(format);\n    [M(I)]public b TryRead(out ulong value,c format='\\0')=>X<ulong,UInt64P>(out value,format);\n    [M(I)]public ulong ReadUInt64(c format='\\0')=>Read<ulong,UInt64P>(format);\n    [M(I)]public b TryRead(out float value,c format='\\0')=>X<float,SingleP>(out value,format);\n    [M(I)]public float ReadSingle(c format='\\0')=>Read<float,SingleP>(format);\n    [M(I)]public b TryRead(out double value,c format='\\0')=>X<double,DoubleP>(out value,format);\n    [M(I)]public double ReadDouble(c format='\\0')=>Read<double,DoubleP>(format);\n    [M(I)]public b TryRead(out decimal value,c format='\\0')=>X<decimal,DecimalP>(out value,format);\n    [M(I)]public decimal ReadDecimal(c format='\\0')=>Read<decimal,DecimalP>(format);\n  }\n}\n")),(0,r.kt)("h2",{id:"announce"},"Announce"),(0,r.kt)("p",null,"In the next posts we will discuss:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Something not about consoles and encodings, enough")),(0,r.kt)("h2",{id:"links"},"Links"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/epeshk/epeshk.text"},"Sources")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.nuget.org/packages/Epeshk.Text/0.0.1"},"Nuget package"))),(0,r.kt)("h2",{id:"homework"},"Homework"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Try ",(0,r.kt)("inlineCode",{parentName:"li"},"AsciiScanner")," on ",(0,r.kt)("a",{parentName:"li",href:"https://timus.online"},"timus")," or ",(0,r.kt)("a",{parentName:"li",href:"https://codeforces.com"},"codeforces")),(0,r.kt)("li",{parentName:"ul"},"Try to find some bugs and if you succeed, open the ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/epeshk/epeshk.text/issues"},"issue")," about it")))}d.isMDXComponent=!0}}]);