"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[994],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),u=p(a),d=r,h=u["".concat(l,".").concat(d)]||u[d]||c[d]||i;return a?n.createElement(h,o(o({ref:t},m),{},{components:a})):n.createElement(h,o({ref:t},m))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},5576:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));const i={slug:"plain-text-io-perf",title:"Text IO Performance",tags:["text_io"]},o="Text IO performance",s={permalink:"/plain-text-io-perf",source:"@site/blog/2022-10-19-plain-text-io-perf.md",title:"Text IO Performance",description:"In the previous post, I discussed the usability flaws of plain-text input parsing in .NET platform. In this post, we will focus on performance issues related to plain-text input and output.",date:"2022-10-19T00:00:00.000Z",formattedDate:"October 19, 2022",tags:[{label:"text_io",permalink:"/tags/text-io"}],readingTime:4.775,hasTruncateMarker:!0,authors:[],frontMatter:{slug:"plain-text-io-perf",title:"Text IO Performance",tags:["text_io"]},prevItem:{title:"Text IO Benchmarks",permalink:"/text-io-benchmarks"},nextItem:{title:"The flaw that reduces C# and .NET popularity",permalink:"/text-io-flaw"}},l={authorsImageUrls:[]},p=[{value:"Which affects plain text IO performance",id:"which-affects-plain-text-io-performance",level:2},{value:"Data source and target",id:"data-source-and-target",level:3},{value:"Operating system",id:"operating-system",level:3},{value:"Language runtime",id:"language-runtime",level:3},{value:"Encoding",id:"encoding",level:3},{value:"Allocations",id:"allocations",level:3},{value:"Parsing",id:"parsing",level:3},{value:"Flushing",id:"flushing",level:3},{value:"Announce",id:"announce",level:2},{value:"Homework",id:"homework",level:2}],m={toc:p};function u(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In the ",(0,r.kt)("a",{parentName:"p",href:"/text-io-flaw"},"previous post"),", I discussed the usability flaws of plain-text input parsing in .NET platform. In this post, we will focus on performance issues related to plain-text input and output."),(0,r.kt)("p",null,"Plain-text IO performance is a big issue for competitive programming. If the input or output is too large, the solution may get Time Limit or Memory Limit exceeded verdict due to inefficient IO. IO will be a bottleneck."),(0,r.kt)("p",null,"Consider the problem ",(0,r.kt)("a",{parentName:"p",href:"https://acm.timus.ru/problem.aspx?space=1&num=1510&locale=en"},"Timus: 1510"),".\nEven a tricky C# solution with optimal ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(n)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")")))))," complexity got Memory Limit Exceeded verdict due to inefficient input parsing. But nonoptimal C++ solution with ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mi",{parentName:"mrow"},"l"),(0,r.kt)("mi",{parentName:"mrow"},"o"),(0,r.kt)("mi",{parentName:"mrow"},"g"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(nlog(n))")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.01968em"}},"l"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"o"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"g"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mclose"},"))")))))," complexity easily got Accepted. The choice of language is a game changer in this case."),(0,r.kt)("h2",{id:"which-affects-plain-text-io-performance"},"Which affects plain text IO performance"),(0,r.kt)("p",null,"Many things affects plain text IO performance. Let's discuss some of this things in theory to set up a correct benchmark."),(0,r.kt)("h3",{id:"data-source-and-target"},"Data source and target"),(0,r.kt)("p",null,"Before reach the program, input data should be loaded from disk or generated by another program. Thus, speed of the disk or efficiency of the generator program may affect benchmark result."),(0,r.kt)("p",null,"If the output stream is piped to a slow application, like terminals, there also will be an issue. Both input and output streams are implemented over bounded buffers, thus our application will be blocked when the terminal app renders old text."),(0,r.kt)("p",null,"Note that redirecting the output e.g. to ",(0,r.kt)("inlineCode",{parentName:"p"},"> nul")," on Windows will lead to false benchmark results because no output will be generated at all (the stdout pipe will not be created at all)."),(0,r.kt)("p",null,"I will get around these issues in the benchmarks by storing input and output data in memory."),(0,r.kt)("h3",{id:"operating-system"},"Operating system"),(0,r.kt)("p",null,"IO streams (pipes) are a tool to pass data from one process to another, managed by the operating system. So, the operating system is responsible for the efficiency of APIs, used to access the internal pipe's buffer."),(0,r.kt)("p",null,"Also blocking may happen where the pipe's buffer is full on write or empty on reading. In this case, the OS thread scheduler is involved."),(0,r.kt)("h3",{id:"language-runtime"},"Language runtime"),(0,r.kt)("p",null,"Programming languages and frameworks abstract the hardware and OS from a programmer, providing an abstraction layer over platform-specific implementation details. The transformation from raw ",(0,r.kt)("inlineCode",{parentName:"p"},"STD_INPUT_HANDLE")," to nice ",(0,r.kt)("inlineCode",{parentName:"p"},"TextReader")," may require hard CPU and memory bus work, like converting, copying, and additional buffering of the data."),(0,r.kt)("p",null,"Language runtime is also responsible for encoding, decoding, and parsing text data."),(0,r.kt)("p",null,"Even for single language, runtime behavior may differ. For C++ we should test against different compilers, and for C# against .NET Framework and modern .NET like 6 and 7."),(0,r.kt)("h3",{id:"encoding"},"Encoding"),(0,r.kt)("p",null,"No text is just plain. The stdin/stdout content is a sequence of bytes, and it is a program's responsibility to interpret it with some encoding. The most common encodings for files are ASCII and UTF-8 (which is the same in range 0-127), but .NET strings use UTF-16. So, the input stream reading to ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," will require data re-encoding."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'ascii("-13") = 2d 31 33\nutf8 ("-13") = 2d 31 33\nutf16("-13") = 2d 00 31 00 33 00\n')),(0,r.kt)("h3",{id:"allocations"},"Allocations"),(0,r.kt)("p",null,"As I mentioned in the previous post, all popular methods for input parsing, like ",(0,r.kt)("inlineCode",{parentName:"p"},"Console.Readline()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"string.Split()"),", ",(0,r.kt)("inlineCode",{parentName:"p"},".Select(int.Parse).ToArray()")," will copy data and allocate new objects. This allocations take some time and memory. Then if the garbage collector will be triggered, it will also take some time to process and clean up these objects."),(0,r.kt)("p",null,"The worst case for .NET is a long single-line input. ",(0,r.kt)("inlineCode",{parentName:"p"},"Console.ReadLine()")," will read all the input in memory, even if it's unnecessary."),(0,r.kt)("h3",{id:"parsing"},"Parsing"),(0,r.kt)("p",null,"The transformations from char sequence to number or backward may be tricky. I recommend you to look at ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/dotnet/runtime/pull/62301"},"this Pull Request")," from ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/dotnet/runtime"},"dotnet/runtime")," about ",(0,r.kt)("inlineCode",{parentName:"p"},"double")," parsing for more information."),(0,r.kt)("p",null,"In some cases, it is worth reimplementing some things, like string to integer conversions, outperforming standard functions. For example, integer parsing may be implemented like this. Of course, this code is not suitable for all cases, but for some it is faster."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int fastscan()\n{\n    bool negative = false;\n    bool read_start = false;\n  \n    int number = 0;\n  \n    while (true)\n    {\n\n#ifdef _WIN32\n        int c = _getchar_nolock();\n#else\n        int c = getchar_unlocked();\n#endif\n        if (c=='-')\n        {\n            negative = true;\n            read_start = true;\n            continue;\n        }\n  \n        if ('0' <= c && c <= '9')\n        {\n            number = number * 10 + (c - '0');\n            read_start = true;\n            continue;\n        }\n\n        if (read_start)\n            break;\n    }\n\n    return negative ? -number : number;\n}\n")),(0,r.kt)("h3",{id:"flushing"},"Flushing"),(0,r.kt)("p",null,"There are two scenarios for output writing:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Interactive console applications, where the following input may depend on output. E.g. a chess program which plays with humans or another programs"),(0,r.kt)("li",{parentName:"ul"},"Non-interactive applications, which may print output after reading all the input.")),(0,r.kt)("p",null,"The interactive output should be propagated to the STDOUT buffer as early as possible, typically line-by-line. But for non-interactive apps, it is not efficient to flush a small amount of data because it will wake the reader application thread only to process this small output and then block on waiting again. Instead, we want to accumulate the output in the own buffer and flush it to STDOUT rarely."),(0,r.kt)("p",null,"Many language runtimes are configured for interactive apps by default. So for fast output, we should reconfigure this behavior."),(0,r.kt)("p",null,".NET methods like ",(0,r.kt)("inlineCode",{parentName:"p"},"Console.WriteLine"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Console.Write")," synchronizes access to the output stream and flush it. So you may improve C# output performance by writing to the buffered output stream:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"using var output = new StreamWriter(Console.OpenStandardOutput());\noutput.WriteLine(...);\n")),(0,r.kt)("h2",{id:"announce"},"Announce"),(0,r.kt)("p",null,"In the next post I'll set up benchmarks to check these concerns on practice and discuss the results."),(0,r.kt)("p",null,"In the following we will discuss:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"How to improve C#/.NET plain-text IO speed"),(0,r.kt)("li",{parentName:"ul"},"Number parsing algorithms"),(0,r.kt)("li",{parentName:"ul"},"Efficient plain-text input reading implementation on C#")),(0,r.kt)("h2",{id:"homework"},"Homework"),(0,r.kt)("p",null,"Solve the ",(0,r.kt)("a",{parentName:"p",href:"https://timus.online/problem.aspx?space=1&num=1510&locale=en"},"Timus: 1510")," problem on C#."))}u.isMDXComponent=!0}}]);