"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[450],{6029:n=>{n.exports=JSON.parse('{"blogPosts":[{"id":"plain-text-io-lib","metadata":{"permalink":"/plain-text-io-lib","source":"@site/blog/2022-12-07-plain-text-io-library.mdx","title":"Text IO Library","description":"Although the previous post revealed that .NET IO performance is not unsatisfactory,","date":"2022-12-07T00:00:00.000Z","formattedDate":"December 7, 2022","tags":[{"label":"text_io","permalink":"/tags/text-io"}],"readingTime":21.375,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"plain-text-io-lib","title":"Text IO Library","tags":["text_io"]},"nextItem":{"title":"Text IO Benchmarks","permalink":"/text-io-benchmarks"}},"content":"Although the [previous post](2022-12-02-plain-text-io-benchmarks.mdx) revealed that .NET IO performance is not unsatisfactory,\\r\\nit remains [inconvenient](2022-10-06-plain-text-io-flaw.md), particularly  for input reading.\\r\\n\\r\\nIn this article, I design and implement a high-performance AOT-friendly input parsing library to replace `int.Parse(Console.Readline())` with something like `sc.ReadInt()`.\\r\\n\\r\\nFurthermore, I give you this [library](https://www.nuget.org/packages/Epeshk.Text) as a concise code snippet that can be easily copied into your program and utilized on online judging systems.\\r\\n\\r\\n\x3c!--truncate--\x3e\\r\\n\\r\\n## Design\\r\\n\\r\\n### Encoding\\r\\n\\r\\nThe primary encoding in the .NET is UTF-16, a 2-byte wide character encoding.\\r\\n\\r\\nHowever, most programming contest problems use much simpler 1-byte wide ASCII input.\\r\\n\\r\\nTherefore, input parsing with string conversion requires data re-encoding, which can negatively impact performance. And it is good for performance to avoid this conversions.\\r\\n\\r\\nI decided to implement three different Scanners for input:\\r\\n - `TextScanner` - a reader which works with the .NET `TextReader` abstraction, reading `char`s rather than raw bytes.\\r\\n - `AsciiScanner` - a reader for ASCII encoding that operates over a byte `Stream`\\r\\n - other `AsciiScanner` - a minified version of the `AsciiScanner`, shortened for use in single-file programs\\r\\n\\r\\n### Parsing\\r\\n\\r\\n#### ASCII\\r\\n\\r\\n.NET already provides an amount of fast APIs for primitive types parsing and we could just use them, saving a lot of time and code size.\\r\\n\\r\\nASCII parser already included in .NET for the `System.Text.Json` purposes.\\r\\nIt is `Utf8Parser` class with static methods for parsing numeric and some other types, like `TimeSpan` and `DateTime` from `Span<byte>`.\\r\\n\\r\\n:::note\\r\\n\\r\\nDon\'t be tricked by naming, in fact, `Utf8Parser` is just an ASCII parser:\\r\\n- It is a low-level thing which couldn\'t handle all Unicode [numeral characters](https://en.wikipedia.org/wiki/Numerals_in_Unicode).\\r\\n- It is named `Utf8` just by use-case, which is extracting plain-text data from UTF-8 data chunks.\\r\\n\\r\\n:::\\r\\n\\r\\nLet\'s look at typical `Utf8Parser` method:\\r\\n```csharp\\r\\nstatic class Utf8Parser\\r\\n{\\r\\n  static bool TryParse(\\r\\n    ReadOnlySpan<byte> source,\\r\\n    out TYPE result,\\r\\n    out int bytesConsumed,\\r\\n    char format=\'\\\\0\');\\r\\n\\r\\n  /* methods for other TYPEs */\\r\\n}\\r\\n```\\r\\n\\r\\nAs we can see, `Utf8Parser` methods can parse values with *scanning* behavior, consuming only some bytes from the Span, without knowing where the data ends. It allows to *scan* data straightforward, without lookahead for the next separator.\\r\\n\\r\\n#### UTF-16\\r\\n\\r\\nUTF-16 can be parsed via methods like `int.TryParse(ReadOnlySpan<char>, IFormatProvider)`.\\r\\nSince .NET 7, these methods also accessible from `ISpanParsable<TSelf>` generic math interface. Let\'s look at it.\\r\\n\\r\\n```csharp\\r\\npublic interface ISpanParsable<TSelf> : IParsable<TSelf>\\r\\n  where TSelf : ISpanParsable<TSelf>?\\r\\n{\\r\\n  static abstract bool TryParse(\\r\\n    ReadOnlySpan<char> s,\\r\\n    IFormatProvider? provider,\\r\\n    out TSelf result);\\r\\n\\r\\n  static abstract TSelf Parse(\\r\\n    ReadOnlySpan<char> s,\\r\\n    IFormatProvider? provider);\\r\\n}\\r\\n```\\r\\n\\r\\nThese methods will return `false` if any other data except value contains in the Span. So, `TextScanner` will not support *scanning* behavior, it will read the data twice: lookahead for delimiter and parse itself.\\r\\n\\r\\n:::note\\r\\n\\r\\nThe buffer contains the text \\"123 456\\"\\r\\n\\r\\nIf the parser support *scanning*, it will return `123` as parsed value and `3` as consumed bytes. So it is possible to build lookahead-free input reading over it.\\r\\n\\r\\nAnd if isn\'t, it will return `false` or throw. So, the caller code should lookahead for whitespace after `123`.\\r\\n\\r\\n:::\\r\\n\\r\\n### Buffering\\r\\n\\r\\nTo use `ISpanParsable<TSelf>` and `Utf8Parser` methods, data should be provided as `ReadOnlySpan<char>` or `ReadOnlySpan<byte>` respectively.\\r\\n\\r\\nSo there is no need for some external buffering layer between `TextReader` or `Stream` and `Scanner`, buffering will occur in the `Scanner` itself.\\r\\n\\r\\nRequired buffer size depends on underlying stream type. If the data already stored in memory, even a small buffer is enough.\\r\\nFor Console stream, especially on Linux, larger buffer (~16 KB) may give a noticeable performance gain.\\r\\n\\r\\nHowever, we could not rely on the assumption that value always fits in the buffer, and should therefore support buffer growing to not be tricked by something like this:\\r\\n\\r\\n<details><summary>this</summary>\\r\\n<p>\\r\\n\\r\\n```\\r\\n0.000000000000000000000000000000000000000000000000000000000000000000000000000000\\r\\n00000000000000000000000000000000000000000000000000000000000000000000000000000000\\r\\n00000000000000000000000000000000000000000000000000000000000000000000000000000000\\r\\n00000000000000000000000000000000000000000000000000000000000000000000000000000000\\r\\n00000494065645841246544176568792868221372365059802614324764425585682500675507270\\r\\n20875186529983636163599237979656469544571773092665671035593979639877479601078187\\r\\n81263007131903114045278458171678489821036887186360569987307230500063874091535649\\r\\n84387312473397273169615140031715385398074126238565591171026658556686768187039560\\r\\n31062493194527159149245532930545654440112748012970999954193198940908041656332452\\r\\n47571478690147267801593552386115501348035264934720193790268107107491703332226844\\r\\n75333572083243193609238289345836806010601150616980975307834227731832924790498252\\r\\n47307763759272478746560847782037344696995336470179726777175851256605511991315048\\r\\n91101451037862738167250955837389733598993664809941164205702637090279242767544565\\r\\n22908753868250641971826553344726562500000000000000000000000000000000000000000000\\r\\n00000000000000000000000000000000000000000000000000000000000000000000000000000000\\r\\n[more zeroes]\\r\\n```\\r\\n\\r\\n</p>\\r\\n</details>\\r\\n\\r\\n### API\\r\\n\\r\\nBecause `AsciiScanner` is based on `Utf8Parser`, I decided to be consistent with `Utf8Parser` methods.\\r\\n```csharp\\r\\nbool TryParse(out int value, char format=\'\\\\0\');\\r\\nbool TryParse(out double value, char format=\'\\\\0\');\\r\\n...\\r\\n```\\r\\n\\r\\n`Utf16Parser` will consistent with `ISpanParsable<TSelf>` methods.\\r\\n```csharp\\r\\nbool TryRead<T>(out T value)\\r\\nbool TryRead<T>(out T value, IFormatProvider formatProvider)\\r\\n```\\r\\n\\r\\nMethod without overload will use `InvariantCulture`. Just because culture-dependency is basically useless for console input.\\r\\n\\r\\n## TextScanner\\r\\n\\r\\n### Interface\\r\\n\\r\\nLet\'s begin with a simple `TextScanner`. It will operate over `TextReader` and read any data type that implements the `ISpanParsable<TSelf>` generic interface.\\r\\nGeneric math has some pros and cons, and constructing a Scanner is a good exercise for understanding them.\\r\\n\\r\\n```csharp\\r\\npublic class TextScanner\\r\\n{\\r\\n  private readonly TextReader reader;\\r\\n\\r\\n  public TextScanner(TextReader? reader=null) => this.reader = reader ?? new TextReader(Console.OpenStandardInput());\\r\\n\\r\\n  public bool TryRead<T>(out T value, IFormatProvider? formatProvider)\\r\\n    where T : ISpanParsable<T>\\r\\n    => throw new NotImplementedException();\\r\\n}\\r\\n```\\r\\n\\r\\nThere is only one method to handle all `ISpanParsable<TSelf>` types! All other, like `.Read<T>` may be extensions. It [already supports](https://learn.microsoft.com/en-us/dotnet/api/system.ispanparsable-1?view=net-7.0) all main numeric types from good old `int` to brand new (for .NET) `Half`. And it is possible to implement this interface for custom type.\\r\\n\\r\\nBut it\'s impossible to extend [existing type](https://github.com/dotnet/runtime/issues/78523) like `bool` with required methods (who says [traits](https://doc.rust-lang.org/rust-by-example/trait.html)?). For this kind of extensibility, we may also introduce `ISpanParser<T>` interface. I will use similar approach [later](#avoiding-code-duplication) for the `AsciiScanner`, because there is no `IAsciiParsable` or `IUtf8Parsable` interface.\\r\\n\\r\\n### Usage sample\\r\\n\\r\\n```csharp\\r\\nvar sc = new TextScanner();\\r\\n\\r\\nvar a = sc.Read<int>();\\r\\nvar b = sc.Read<int>();\\r\\n\\r\\nwhile (sc.TryRead(out double d))\\r\\n{\\r\\n}\\r\\n```\\r\\n\\r\\nYes, `.Read<int>()` may be hard to type, because explicit generic parameter syntax isn\'t well supported by code completion, but it\'s always possible to add an extension, e.g. `.ReadInt()`, or even simpler: `.Int()`\\r\\n\\r\\n### TryRead\\r\\n\\r\\nNow we need to implement `TryRead<T>(out T value, IFormatProvider)` method. `ISpanParsable<TSelf>.TryParse` accepts `ReadOnlySpan<char>` for parsing. So, we need to use some `char[]` buffer for `TextReader` data.\\r\\n\\r\\nSo, logic of this method is pretty straightforward:\\r\\n- Do lookahead for the next token. Method which performs lookahead is also fetch the data.\\r\\n\\r\\n  Token is a sequence of characters between separators, e.g. whitespaces). Line `123 456 789` contains three tokens: `123`, `456`, `789`.\\r\\n- Try parse this token with `T.TryParse` method.\\r\\n- If parsing is successful, move offset in the internal buffer.\\r\\n\\r\\n```csharp\\r\\npublic bool TryRead<T>(out T value, IFormatProvider? formatProvider=null)\\r\\n  where T : ISpanParsable<T>\\r\\n{\\r\\n  ReadOnlySpan<char> span = GetNextToken();\\r\\n  if (!T.TryParse(span, formatProvider, out value))\\r\\n    return false;\\r\\n\\r\\n  Consume(span.Length);\\r\\n  return true;\\r\\n}\\r\\n\\r\\nprivate char[] buffer;\\r\\nprivate int length;\\r\\nprivate int offset;\\r\\n\\r\\nprivate void Consume(int bytes) => offset += bytes;\\r\\n```\\r\\n\\r\\n### GetNextToken\\r\\n\\r\\nNow we need a core method of the TextScanner, `GetNextToken`. For best performance, this function is divided to the fast and slow path.\\r\\n\\r\\nFast path is a short inlineable function which handles a case when the token fits in the buffer. Slow path is triggered when end of the buffer was reached, or when the buffer is too small for the next token.\\r\\n\\r\\n```csharp\\r\\nprivate ReadOnlySpan<char> GetNextToken()\\r\\n{\\r\\n  SkipDelimiters();\\r\\n\\r\\n  int end = FindDelimiter(offset);\\r\\n\\r\\n  if (end < length)\\r\\n    return buffer.AsSpan(offset, end - offset);\\r\\n\\r\\n  return GetNextTokenRare();\\r\\n}\\r\\n\\r\\nprivate void SkipDelimiters()\\r\\n{\\r\\n  while (offset < length && IsDelimiter(buffer[offset]))\\r\\n    offset++;\\r\\n}\\r\\n\\r\\nprivate int FindDelimiter(int end)\\r\\n{\\r\\n  while (end < length && !IsDelimiter(buffer[end]))\\r\\n    end++;\\r\\n  return end;\\r\\n}\\r\\n\\r\\n```\\r\\n\\r\\n<details><summary>Slow path & Fetch data implementation</summary>\\r\\n<p>\\r\\n\\r\\n```csharp\\r\\n// clearly show our intention to make rare called code path\\r\\n[MethodImpl(MethodImplOptions.NoInlining)]\\r\\nprivate ReadOnlySpan<char> GetNextTokenRare()\\r\\n{\\r\\n  while (offset == length)\\r\\n  {\\r\\n    if (!FetchData())\\r\\n      return ReadOnlySpan<char>.Empty;\\r\\n\\r\\n    SkipDelimiters();\\r\\n  }\\r\\n\\r\\n  MoveDataToBufferStart();\\r\\n\\r\\n  int end = 0;\\r\\n\\r\\n  while (true)\\r\\n  {\\r\\n    end = FindDelimiter(end);\\r\\n\\r\\n    if (end < length)\\r\\n      return buffer.AsSpan(0, end);\\r\\n\\r\\n    if (!FetchData())\\r\\n      return buffer.AsSpan(0, end);\\r\\n  }\\r\\n}\\r\\n\\r\\nprivate bool FetchData()\\r\\n{\\r\\n  MoveDataToBufferStart();\\r\\n\\r\\n  if (length == buffer.Length)\\r\\n    GrowBuffer();\\r\\n\\r\\n  // read the data from TextReader right after remaining data\\r\\n  int count = reader.Read(buffer, length, buffer.Length - length);\\r\\n\\r\\n  // end of the data reached\\r\\n  if (count > 0)\\r\\n    length += count;\\r\\n\\r\\n  return count > 0;\\r\\n}\\r\\n\\r\\nprivate void MoveDataToBufferStart()\\r\\n{\\r\\n  // calculate the length of unused data span\\r\\n  int remaining = length - offset;\\r\\n\\r\\n  // shift unused data to the beginning\\r\\n  buffer.AsSpan(offset, remaining).CopyTo(buffer);\\r\\n  offset = 0;\\r\\n  length = remaining;\\r\\n}\\r\\n\\r\\nprivate void GrowBuffer()\\r\\n{\\r\\n  var newBuffer = new char[buffer.Length * 2];\\r\\n  buffer.CopyTo(newBuffer, 0);\\r\\n  buffer = newBuffer;\\r\\n}\\r\\n```\\r\\n\\r\\n</p>\\r\\n</details>\\r\\n\\r\\n### Char & String\\r\\n\\r\\nIn some contest problems, input was given as a matrix of the characters. E.g. this matrix represents [glider](https://en.wikipedia.org/wiki/Glider_(Conway%27s_Life)) from the [Game of Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life):\\r\\n<pre>\\r\\n5 9<br/>\\r\\n000000000<br/>\\r\\n0000<b>1</b>0000<br/>\\r\\n00000<b>1</b>000<br/>\\r\\n000<b>111</b>000<br/>\\r\\n000000000\\r\\n</pre>\\r\\n\\r\\nSome programmers used to parse inputs like this, char by char:\\r\\n\\r\\n```csharp\\r\\nint n = sc.Read<int>();\\r\\nint m = sc.Read<int>();\\r\\n\\r\\nchar[,] arr = new char[n, m];\\r\\n\\r\\nfor (int i = 0; i < n; ++i)\\r\\nfor (int j = 0; j < m; ++j)\\r\\n  arr[i, j] = sc.Read<char>();\\r\\n```\\r\\n\\r\\nAnd this code will compiles with our Scanner. Because char implements `ISpanParsable<TSelf>`. But our current implementation of the TextScanner parses tokens between delimiters, so it will try to parse whole line as single character.\\r\\n\\r\\nSo, we need to add type-specific parts for this case in our code. Luckily, it will not hit performance, because compilers may eliminate conditions like `typeof(T) == typeof(char)` during generic specification.\\r\\n\\r\\nNote that `string` isn\'t `ISpanParsable<TSelf>`, so it is useful to support string reading:\\r\\n\\r\\n```csharp\\r\\nint n = sc.Read<int>();\\r\\nint m = sc.Read<int>();\\r\\n\\r\\nstring[] arr = new string[n];\\r\\n\\r\\nfor (int i = 0; i < n; ++i)\\r\\n  arr[i] = sc.ReadToken();\\r\\n```\\r\\n\\r\\nAs you remember, we already implemented `ReadToken`, now just create overload which copies data from buffer-backed `ReadOnlySpan` to the new `string`\\r\\n\\r\\n```csharp\\r\\n  public bool TryReadString(out string value)\\r\\n  {\\r\\n    value = GetNextToken().ToString();\\r\\n    Consume(value.Length);\\r\\n    return value.Length > 0;\\r\\n  }\\r\\n```\\r\\n\\r\\n### Delimiter handling\\r\\n\\r\\nThe only remaining method is `IsDelimiter`.\\r\\n\\r\\nIt is a hot path in `TextScanner` code, as it is called for every character of the input. As such, supporting custom delimiters requires additional research on usability and performance. `char.IsWhitespace` check is enough for programming contest\'s problems. However, other delimiters useful to support parsing of CSV files and markdown tables.\\r\\n\\r\\nNote that it is not worth to optimize `IsDelimiter` method for fast skipping of many delimiters. In most cases, delimiter is just a single space or line break.\\r\\n\\r\\n### Performance\\r\\n\\r\\n<details><summary>Benchmark code</summary>\\r\\n<p>\\r\\n\\r\\n```csharp\\r\\n[Benchmark]\\r\\npublic void Scanner()\\r\\n{\\r\\n  using var sr = new StringReader(input);\\r\\n  using var scanner = new TextScanner(sr);\\r\\n\\r\\n  while (scanner.TryRead(out int _)) ;\\r\\n}\\r\\n\\r\\n[Benchmark]\\r\\npublic void ReadInt_ReadLine()\\r\\n{\\r\\n  using var sr = new StringReader(input);\\r\\n\\r\\n  while (true)\\r\\n  {\\r\\n    var line = ms.ReadLine();\\r\\n    if (line == null) break;\\r\\n\\r\\n    foreach (var s in line.Split())\\r\\n    {\\r\\n      int.Parse(s);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\n</p>\\r\\n</details>\\r\\n\\r\\n1M integers, written in the single line:\\r\\n\\r\\n```\\r\\n|           Method |     Mean |      Gen0 |      Gen1 |      Gen2 |   Allocated |\\r\\n|----------------- |---------:|----------:|----------:|----------:|------------:|\\r\\n|          ReadInt | 23.48 ms |         - |         - |         - |     1.12 KB |\\r\\n| ReadInt_ReadLine | 90.97 ms | 3833.3333 | 3666.6667 | 1166.6667 | 53525.25 KB |\\r\\n\\r\\n```\\r\\n\\r\\n1M integers, written in 4 columns and 250K lines:\\r\\n```\\r\\n|           Method |      Gen0 |  Allocated |\\r\\n|----------------- |----------:|-----------:|\\r\\n|          ReadInt |         - |    1.12 KB |\\r\\n| ReadInt_ReadLine | 5307.6923 | 86968.2 KB |\\r\\n```\\r\\n\\r\\nWith the real `Console` stream, this implementation work with additional 2ms overhead over `fastscan`.\\r\\n\\r\\n## AsciiScanner\\r\\n\\r\\n### Interface\\r\\n\\r\\nFor more impressive performance gains we need to get rid of character encoding conversion.\\r\\n`AsciiScanner` and `Utf8Scanner` will operate over bytes `Stream` in ASCII or UTF-8 encoding and read any data type that [supported](https://learn.microsoft.com/en-us/dotnet/api/system.buffers.text.utf8parser?view=net-7.0) by the `Utf8Parser` class.\\r\\n\\r\\n```csharp\\r\\npublic class AsciiScanner : IDisposable\\r\\n{\\r\\n  private readonly Stream stream;\\r\\n\\r\\n  public AsciiScanner(Stream stream=null) => this.stream = stream ?? Console.OpenStandardInput();\\r\\n\\r\\n  public bool TryReadInt32(out T value, char format=\'\\\\0\') { ... }\\r\\n  public bool TryReadInt64(out T value, char format=\'\\\\0\') { ... }\\r\\n  public bool TryReadDouble(out T value, char format=\'\\\\0\') { ... }\\r\\n  ...\\r\\n\\r\\n  public bool Dispose() => stream.Dispose();\\r\\n}\\r\\n\\r\\npublic static class AsciiScannerExtensions\\r\\n{\\r\\n  public static bool ReadInt32(this AsciiScanner sc, char format=\'\\\\0\');\\r\\n  public static bool ReadInt64(this AsciiScanner sc, char format=\'\\\\0\');\\r\\n  public static bool ReadDouble(this AsciiScanner sc, char format=\'\\\\0\');\\r\\n  ...\\r\\n}\\r\\n```\\r\\n\\r\\nI use long `ReadIntXX` names due to the [design guideline](https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/general-naming-conventions#avoiding-language-specific-names) about generic CLR type names.\\r\\n\\r\\n### Usage sample\\r\\n\\r\\n```csharp\\r\\nvar sc = new AsciiScanner();\\r\\n\\r\\nvar a = sc.ReadInt32();\\r\\nvar b = sc.ReadInt32();\\r\\n\\r\\nwhile (sc.TryReadDouble(out var d))\\r\\n{\\r\\n}\\r\\n```\\r\\n\\r\\nAnyway, `.ReadInt32()` is easier to type than `.Read<int>()` and also has great completion support.\\r\\n\\r\\n### Avoiding code duplication\\r\\n\\r\\nBecause there is no `Utf8Parsable` interface, and we should use a set of static methods for parsing, straightforward implementation for all the types will lead to code duplication. To avoid this, let\'s introduce interface for this purpose! Not `IUtf8Parsable`, but `IUtf8Parser` (or just, `IParser`).\\r\\n\\r\\n```csharp\\r\\ninterface IParser<T>\\r\\n{\\r\\n  bool TryParse(\\r\\n    ReadOnlySpan<byte> source,\\r\\n    out T value,\\r\\n    out int bytesConsumed,\\r\\n    char standardFormat = default);\\r\\n}\\r\\n```\\r\\n\\r\\nNow `AsciiScanner` can be rewritten with generic core method. `TParser` constrained to value types for generic specification: compiler will statically generate code for each type avoiding costs of generic call.\\r\\n\\r\\nBecause it is too boring and unmaintainable to write all `IParser` implementations manually, I used source generation for this purpose. This approach may also be used to backport `TextScanner` to older versions of .NET without generic math.\\r\\n\\r\\n```csharp\\r\\npublic class AsciiScanner : IDisposable\\r\\n{\\r\\n  ...\\r\\n  public bool TryRead(out T value, char format=\'\\\\0\')\\r\\n    => TryRead<int, Int32Parser>(out value, format);\\r\\n  public bool TryRead(out T value, char format=\'\\\\0\')\\r\\n    => TryRead<long, Int64Parser>(out value, format);\\r\\n  public bool TryRead(out T value, char format=\'\\\\0\')\\r\\n    => TryRead<double, DoubleParser>(out value, format);\\r\\n  ...\\r\\n\\r\\n  private bool TryRead<T, TParser> TryRead(\\r\\n    out T value, char format=\'\\\\0\', TParser parser=default)\\r\\n    where TParser : struct, IParser<T>\\r\\n    => throw new NotImplementedException();\\r\\n\\r\\n  public bool Dispose() => stream.Dispose();\\r\\n}\\r\\n```\\r\\n\\r\\n### TryRead\\r\\n\\r\\nBecause `Utf8Parser` methods allow scanning behavior, `TryRead` can be implemented in two ways:\\r\\n - like `TextScanner`: read token between delimiters, then parse it.\\r\\n - without lookahead: try parse token, then update buffer if needed and retry\\r\\n\\r\\n### Token based approach\\r\\n\\r\\n```csharp\\r\\nprivate bool TryRead<T, TParser>(out T value, char format=\'\\\\0\', TParser parser=default)\\r\\n  where TParser : struct, IParser<T>\\r\\n{\\r\\n  ReadOnlySpan<byte> span = GetNextToken();\\r\\n  if (!parser.TryParse(span, out value, out int bytesConsumed, format))\\r\\n    return false;\\r\\n\\r\\n  Consume(bytesConsumed);\\r\\n  return true;\\r\\n}\\r\\n```\\r\\n\\r\\nThis approach with simplified delimiter handling (only 1-byte whitespaces) could be implemented mostly by replacing `char` to `byte` in the previous `TextScanner` code. So, it is easy to estimate it\'s performance.\\r\\n\\r\\n|           Method |     Mean |\\r\\n|----------------- |---------:|\\r\\n|          ReadInt | 23.65 ms |\\r\\n|     AsciiReadInt | 17.90 ms |\\r\\n\\r\\nNot impressive at all, right? So, we need to go with a scanning approach.\\r\\n\\r\\n### Scanning approach\\r\\n\\r\\nCode for the scanning much more complex than for reading by tokens. The main problem is incomplete values on the end of the buffer.\\r\\n\\r\\nSince `AsciiScanner/Utf8Scanner` read stream by blocks and tokens are not prepared, it could end up with parsing a torn value. For example, value `123456` could be fetched into buffer by two separate reads as: `[... 1234][56 ...]`. And value `1234` would be parsed by `Utf8Parser` because it is a valid integer.\\r\\n\\r\\nTo avoid this false-positives, any successful value read from the end of the buffer should be retried if more data available in the stream.\\r\\n\\r\\nFor other kind of incomplete values `Utf8Parser` will return false and report zero bytes consumed. It is something like `1e9` value fetched as [... 1e][9 ..]. Unfortunatelly, `Utf8Parser.Parse` methods can\'t tell if it is invalid value, or just more data required.\\r\\n\\r\\nSo, I\'m using some heuristics to determine if the failed read is real one and not caused by a torn value:\\r\\n\\r\\n- If we close to end of the buffer, retry with more data when possible.\\r\\n\\r\\n  It helps against `[ ..tr][ue.. ]` and `[.. -][1 ..]`:\\r\\n  - some of this limits can be found in dotnet [sources](https://github.com/dotnet/runtime/blob/38ca26b27b9e7a867e6ff69eec3cabbfb4e9e1cf/src/libraries/System.Private.CoreLib/src/System/Number.NumberBuffer.cs#L13)\\r\\n  - `bool` has maximum 5 characters\\r\\n  - `(u)long` has maximum 20 characters\\r\\n  - `decimal` has maximum 40 characters\\r\\n  - `(U)Int128` has maximum 40 characters\\r\\n  - `Guid` has maximum 38 characters in the `{nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn}` form\\r\\n\\r\\n- Floating point values are unbounded, so we can\'t rely on length alone. I tried to use other heuristic:\\r\\n  - Still retry if the length are less than 10 bytes (for `NaN` and `-Infinity`)\\r\\n  - Retry if the last byte in the buffer in `eE+-.,:/TZ` to avoid split in `1234567890e-2` and Date/Time types\\r\\n  - Maybe there are other cases which should be handled\\r\\n\\r\\n### Implementation\\r\\n\\r\\nIt is good for performance to make the most frequently path short, inlineable and highly optimized.\\r\\nThe approach of separating hot and cold code also allows not to worry too much about performance of the cold (rare) parts.\\r\\n\\r\\nLet\'s decide which paths in the `AsciiScanner` should be considered hot:\\r\\n - value fits in the buffer\\r\\n - reads are successful\\r\\n\\r\\nMethods with `Rare` suffix handle cold cases:\\r\\n - loading data from stream into the buffer\\r\\n - multibyte delimiters in the `Utf8Scanner`\\r\\n\\r\\n```csharp\\r\\nprivate byte[] buffer;\\r\\nprivate int offset;\\r\\nprivate int length;\\r\\n\\r\\nprivate Span<byte> Fragment => buffer.AsSpan(offset, length - offset);\\r\\n\\r\\nprivate bool TryRead<T, TParser>(out T value, char format=\'\\\\0\', TParser parser=default)\\r\\n  where TParser : struct, IParser<T>\\r\\n  => TryReadInBuffer(out value, format, parser) ??\\r\\n     TryReadRare(out value, format, parser);\\r\\n\\r\\nprivate bool? TryReadInBuffer<T, TParser>(out T value, char format=\'\\\\0\', TParser parser=default)\\r\\n  where TParser : struct, IParser<T>\\r\\n{\\r\\n  value = default!;\\r\\n\\r\\n  if (!SkipDelimiters())\\r\\n    return null;\\r\\n\\r\\n  if (!parser.TryParse(Fragment, out value, out int bytesConsumed, format))\\r\\n    return IsReadIncomplete<T>() ? null : false;\\r\\n\\r\\n  if (offset + bytesConsumed >= length)\\r\\n    return null;\\r\\n\\r\\n  offset += bytesConsumed;\\r\\n  return true;\\r\\n}\\r\\n\\r\\nprivate bool SkipDelimiters()\\r\\n{\\r\\n  while (offset < length)\\r\\n  {\\r\\n    var ch = buffer[offset];\\r\\n    if (!IsAsciiDelimiter(ch))\\r\\n      return ch < 0xC0 || SkipDelimitersRare(); // for AsciiScanner just return true\\r\\n    offset++;\\r\\n  }\\r\\n\\r\\n  return false;\\r\\n}\\r\\n\\r\\nprivate static bool IsAsciiDelimiter(byte c)\\r\\n  => (byte)(c - 9) <= 5 || c == 32;\\r\\n\\r\\n// AsciiScanner\\r\\n// private static bool IsAsciiDelimiter(byte c)\\r\\n//  => c <= 32;\\r\\n```\\r\\n\\r\\n<details><summary>Slow path</summary>\\r\\n<p>\\r\\n\\r\\n```csharp\\r\\n[MethodImpl(MethodImplOptions.NoInlining)]\\r\\nprivate bool TryReadRare<T, TParser>(out T value, char format=\'\\\\0\', TParser parser=default)\\r\\n  where TParser : struct, IParser<T>\\r\\n{\\r\\n  while (FetchData())\\r\\n  {\\r\\n    var readInBuffer = TryReadInBuffer(out value, format, parser);\\r\\n    if (readInBuffer.HasValue)\\r\\n      return readInBuffer.GetValueOrDefault();\\r\\n  }\\r\\n\\r\\n  var result = parser.TryParse(Fragment, out value, out var bc, format);\\r\\n  offset += bc;\\r\\n  return result;\\r\\n}\\r\\n\\r\\n// FetchData is similar to TextScanner\\r\\n\\r\\n```\\r\\n\\r\\n</p>\\r\\n</details>\\r\\n\\r\\n### UTF-8 support\\r\\n\\r\\nFor simple UTF-8 support `AsciiScanner` may just skip all non-ASCII bytes. Anyway, `Utf8Parser` parses only ASCII input.\\r\\n\\r\\nTo achieve full-featured UTF-8 support, `Rune` type can be used since .NET Core 3.0. Unlike 16-bit `char`, 32-bit `Rune` type represents any Unicode codepoint.\\r\\n\\r\\nSome operations, like whitespace skipping also may be reimplemented without using the `Rune` type for additional performance, but I\'m not sure that it is worth it, especially in the blog post code.\\r\\n\\r\\nFor character and string reading, `IParser<char>`, `IParser<Rune>`, `IParser<string>` may be implemented.\\r\\n\\r\\n<details><summary>SkipDelimitersRare with `Rune` type</summary>\\r\\n<p>\\r\\n\\r\\n```csharp\\r\\n[MethodImpl(MethodImplOptions.NoInlining)]\\r\\nprivate bool SkipDelimitersRare()\\r\\n{\\r\\n  while (offset < length)\\r\\n  {\\r\\n    var val = buffer[offset];\\r\\n\\r\\n    if (IsAsciiDelimiter(val))\\r\\n    {\\r\\n      offset++;\\r\\n      continue;\\r\\n    }\\r\\n\\r\\n    var status = Rune.DecodeFromUtf8(Fragment, out Rune rune, out int bytesConsumed);\\r\\n    if (status is not OperationStatus.Done)\\r\\n      return false;\\r\\n    if (!Rune.IsWhiteSpace(rune))\\r\\n      return true;\\r\\n    offset += bytesConsumed;\\r\\n  }\\r\\n\\r\\n  return false;\\r\\n}\\r\\n```\\r\\n\\r\\n</p>\\r\\n</details>\\r\\n\\r\\n### Performance\\r\\n#### Reading from MemoryStream:\\r\\n\\r\\n|       Method |     Mean |\\r\\n|------------- |---------:|\\r\\n|  TextScanner | 23.51 ms |\\r\\n|  Utf8Scanner | 12.18 ms |\\r\\n| AsciiScanner | 11.47 ms |\\r\\n\\r\\n#### Reading from Console:\\r\\n\\r\\n<details><summary>Windows</summary>\\r\\n<p>\\r\\n\\r\\n|      Program |Lang |  Compiler | Mean (Int) | Mean (Double) |\\r\\n|------------- |---- |---------- |-----------:|--------------:|\\r\\n| **AsciiScanner** | **C#**  | **NativeAOT** |      **30 ms** |         **50 ms** |\\r\\n|     fastscan | C++ |    msvc64 |      34 ms |             - |\\r\\n|     fastscan | C#  | NativeAOT |      36 ms |             - |\\r\\n|  **TextScanner** | **C#**  | **NativeAOT** |      **36 ms** |         **66 ms** |\\r\\n|     fastscan | C++ |     g++64 |      45 ms |             - |\\r\\n| **AsciiScanner** | **C#**  |       **JIT** |      **56 ms** |         **75 ms** |\\r\\n|     fastscan | C#  |       JIT |      58 ms |             - |\\r\\n|      console | C#  | NativeAOT |      58 ms |         92 ms |\\r\\n|  **TextScanner** | **C#**  |       **JIT** |      **64 ms** |         **92 ms** |\\r\\n|     cin_fast | C++ |     g++64 |      74 ms |       1650 ms |\\r\\n|        scanf | C++ |    msvc64 |      76 ms |        100 ms |\\r\\n|      console | C#  |       JIT |      85 ms |        117 ms |\\r\\n|        token | Kt  |       JVM |     121 ms |        121 ms |\\r\\n|     slowscan | C#  |       JIT |     117 ms |             - |\\r\\n|     slowscan | C#  | NativeAOT |     121 ms |             - |\\r\\n|        scanf | C++ |     g++64 |     190 ms |        310 ms |\\r\\n|     cin_fast | C++ |    msvc64 |     243 ms |        274 ms |\\r\\n|          cin | C++ |    msvc64 |     271 ms |        300 ms |\\r\\n|          cin | C++ |     g++64 |     424 ms |       2000 ms |\\r\\n|      scanner | Kt  |       JVM |     485 ms |       2000 ms |\\r\\n\\r\\n</p>\\r\\n</details>\\r\\n\\r\\n<details><summary>Linux</summary>\\r\\n<p>\\r\\n\\r\\n|  Program |Lang |  Compiler | Mean (Int) | Mean (Double) |\\r\\n|--------- |---- |---------- |-----------:|--------------:|\\r\\n| fastscan | C++ |     g++64 |      14 ms |             - |\\r\\n| **AsciiScanner** | **C#** | **NativeAOT** |   **14 ms** |         **40 ms** |\\r\\n| fastscan | C#  | NativeAOT |      27 ms |             - |\\r\\n| **TextScanner** | **C#**  | **NativeAOT** |   **26 ms** |         **74 ms** |\\r\\n| cin_fast | C++ |     g++64 |      38 ms |        101 ms |\\r\\n|    scanf | C++ |     g++64 |      44 ms |         70 ms |\\r\\n|  console | C#  | NativeAOT |      64 ms |        117 ms |\\r\\n|    token | Kt  |       JVM |      97 ms |         97 ms |\\r\\n| **AsciiScanner** | **C#**  | **JIT** |     **106 ms** |          **140 ms** |\\r\\n| slowscan | C#  | NativeAOT |     125 ms |             - |\\r\\n|      cin | C++ |     g++64 |     150 ms |        220 ms |\\r\\n|  **TextScanner** | **C#**  |       **JIT** |     **155 ms** |       **205 ms** |\\r\\n|  console | C#  |       JIT |     160 ms |        200 ms |\\r\\n| slowscan | C#  |       JIT |     230 ms |             - |\\r\\n|  scanner | Kt  |       JVM |     500 ms |       1080 ms |\\r\\n\\r\\n</p>\\r\\n</details>\\r\\n\\r\\nWho want to say now that C# Console IO is slow and unsuitable for competitive programming?!\\r\\n\\r\\n## Reduced AsciiScanner\\r\\n\\r\\nThe main purpose of the reduced version is usage in single-file programs, like solutions for contest\'s problems.\\r\\n\\r\\nSo, limitations for the reduced version are:\\r\\n- targeting netstandard2.0 or netcoreapp3.1 to be supported by the automatic judging systems like [timus](https://timus.online/) and [codeforces](https://codeforces.com)\\r\\n- C# language version is 8\\r\\n- source code must be easily embeddable to another program\\r\\n- source code must be relatively short to save a space for useful code.\\r\\n\\r\\nAnd here it is! Just paste it to the end of your single-file program and enjoy new input.\\r\\n\\r\\nThis code is not as small as I wanted, but it is mostly due to definitions for each supported type. Core logic is around 2 KB. Yes, `TextScanner` with generic math is shorter, but .NET 7 is not wide supported yet.\\r\\n\\r\\nFor shorteness, you may keep only the code for common types: `(u)int`, `(u)long`, `float`, `double`.\\r\\n\\r\\n```csharp\\r\\n// ReSharper disable All\\r\\nnamespace Epeshk.Text\\r\\n{\\r\\n  using System;using System.IO;using System.Text;using M=System.Runtime.CompilerServices.MethodImplAttribute;\\r\\n  using O=System.Runtime.CompilerServices.MethodImplOptions;using S=System.ReadOnlySpan<byte>;\\r\\n  using U=System.Buffers.Text.Utf8Parser;using n=System.Int32;using b=System.Boolean;using c=System.Char;\\r\\n\\r\\n  class AsciiScanner{\\r\\n    const O I=O.AggressiveInlining;const O N=O.NoInlining;byte[] b;n l,o;readonly Stream s;\\r\\n    public AsciiScanner(Stream stream=null,n size=8192){s=stream??Console.OpenStandardInput();b=new byte[size];}\\r\\n    b X<T,TP>(out T v,c f=\'\\\\0\',TP p=default)where TP:struct,G<T> =>A(out v,f,p)??W(out v,f,p);\\r\\n    b? A<T,TP>(out T v,c f=\'\\\\0\',TP p=default)where TP:struct,G<T>{v=default;if(!E())return null;if\\r\\n    (!p.P(S,out v,out n b,f))return K<T>()?(b?)null:false;if(o+b>=l)return null;o+=b;return true;}\\r\\n    [M(I)]b W<T,TP>(out T v,c f=\'\\\\0\',TP p=default)where TP:struct,G<T>{while(F()){var q=A(out v,f,p);if(q.HasValue)\\r\\n    return q.GetValueOrDefault();}var r=p.P(S,out v,out var bc,f);o+=bc;return r;}\\r\\n    Span<byte> S=>b.AsSpan(o,l-o);\\r\\n    b K<T>()=>typeof(T)==typeof(double)||typeof(T)==typeof(float)?K():S.Length<32;\\r\\n    [M(N)]b K(){var s=S;if (s.Length<10)return false;var c=s[^1];return c-\'+\'<=\'/\'-\'+\'||(c&~32)is\'E\';}\\r\\n    b E(){while(o<l){if(!D(b[o]))return true;o++;}return false;}\\r\\n    b F(){R();if(l==b.Length)H();n c=s.Read(b,l,b.Length-l);if(c>0)l+=c;return c>0;}\\r\\n    void R(){n r=l-o;b.AsSpan(o,r).CopyTo(b);o=0;l=r;}\\r\\n    [M(I)]static b D(byte c)=>(byte)(c+128)<=160;\\r\\n    void H(){var c=new byte[b.Length*2];b.CopyTo(c,0);b=c;}\\r\\n    static void Q()=>throw new FormatException();\\r\\n    interface G<T>{b P(S s,out T v,out n c,c f);}\\r\\n    struct CharP:G<c>{public b P(S s,out c v,out n c,c f){if(s.IsEmpty){v=default; c=0;return false;}v=(c)s[0];c=1;return true;}}\\r\\n    struct StringP:G<string>{public b P(S s,out string v,out n c,c f){if(s.IsEmpty){v=default;c=0;return false;}\\r\\n    var sb=new StringBuilder();foreach(var b in s){if(D(b))break;sb.Append((c)b);}v=sb.ToString();c=v.Length;return true;}}\\r\\n    [M(I)]T Read<T,TP>(c f=\'\\\\0\')where TP:struct,G<T>{if(!X<T,TP>(out T v, f))Q();return v;}\\r\\n\\r\\n    [M(I)]public b TryRead(out string value)=>X<string,StringP>(out value);\\r\\n    [M(I)]public string ReadString()=>Read<string,StringP>();\\r\\n    [M(I)]public b TryRead(out c value)=>X<c,CharP>(out value);\\r\\n    [M(I)]public c ReadChar()=>Read<c,CharP>();\\r\\n    struct BoolP:G<b>{[M(I)]public b P(S s,out b v,out n c,c f)=>U.TryParse(s,out v,out c,f);}\\r\\n    struct SByteP:G<sbyte>{[M(I)]public b P(S s,out sbyte v,out n c,c f)=>U.TryParse(s,out v,out c,f);}\\r\\n    struct ByteP:G<byte>{[M(I)]public b P(S s,out byte v,out n c,c f)=>U.TryParse(s,out v,out c,f);}\\r\\n    struct Int16P:G<short>{[M(I)]public b P(S s,out short v,out n c,c f)=>U.TryParse(s,out v,out c,f);}\\r\\n    struct UInt16P:G<ushort>{[M(I)]public b P(S s,out ushort v,out n c,c f)=>U.TryParse(s,out v,out c,f);}\\r\\n    struct Int32P:G<n>{[M(I)]public b P(S s,out n v,out n c,c f)=>U.TryParse(s,out v,out c,f);}\\r\\n    struct UInt32P:G<uint>{[M(I)]public b P(S s,out uint v,out n c,c f)=>U.TryParse(s,out v,out c,f);}\\r\\n    struct Int64P:G<long>{[M(I)]public b P(S s,out long v,out n c,c f)=>U.TryParse(s,out v,out c,f);}\\r\\n    struct UInt64P:G<ulong>{[M(I)]public b P(S s,out ulong v,out n c,c f)=>U.TryParse(s,out v,out c,f);}\\r\\n    struct SingleP:G<float>{[M(I)]public b P(S s,out float v,out n c,c f)=>U.TryParse(s,out v,out c,f);}\\r\\n    struct DoubleP:G<double>{[M(I)]public b P(S s,out double v,out n c,c f)=>U.TryParse(s,out v,out c,f);}\\r\\n    struct DecimalP:G<decimal>{[M(I)]public b P(S s,out decimal v,out n c,c f)=>U.TryParse(s,out v,out c,f);}\\r\\n    [M(I)]public b TryRead(out b value,c format=\'\\\\0\')=>X<b,BoolP>(out value,format);\\r\\n    [M(I)]public b ReadBool(c format=\'\\\\0\')=>Read<b,BoolP>(format);\\r\\n    [M(I)]public b TryRead(out sbyte value,c format=\'\\\\0\')=>X<sbyte,SByteP>(out value,format);\\r\\n    [M(I)]public sbyte ReadSByte(c format=\'\\\\0\')=>Read<sbyte,SByteP>(format);\\r\\n    [M(I)]public b TryRead(out byte value,c format=\'\\\\0\')=>X<byte,ByteP>(out value,format);\\r\\n    [M(I)]public byte ReadByte(c format=\'\\\\0\')=>Read<byte,ByteP>(format);\\r\\n    [M(I)]public b TryRead(out short value,c format=\'\\\\0\')=>X<short,Int16P>(out value,format);\\r\\n    [M(I)]public short ReadInt16(c format=\'\\\\0\')=>Read<short,Int16P>(format);\\r\\n    [M(I)]public b TryRead(out ushort value,c format=\'\\\\0\')=>X<ushort,UInt16P>(out value,format);\\r\\n    [M(I)]public ushort ReadUInt16(c format=\'\\\\0\')=>Read<ushort,UInt16P>(format);\\r\\n    [M(I)]public b TryRead(out n value,c format=\'\\\\0\')=>X<n,Int32P>(out value,format);\\r\\n    [M(I)]public n ReadInt32(c format=\'\\\\0\')=>Read<n,Int32P>(format);\\r\\n    [M(I)]public b TryRead(out uint value,c format=\'\\\\0\')=>X<uint,UInt32P>(out value,format);\\r\\n    [M(I)]public uint ReadUInt32(c format=\'\\\\0\')=>Read<uint,UInt32P>(format);\\r\\n    [M(I)]public b TryRead(out long value,c format=\'\\\\0\')=>X<long,Int64P>(out value,format);\\r\\n    [M(I)]public long ReadInt64(c format=\'\\\\0\')=>Read<long,Int64P>(format);\\r\\n    [M(I)]public b TryRead(out ulong value,c format=\'\\\\0\')=>X<ulong,UInt64P>(out value,format);\\r\\n    [M(I)]public ulong ReadUInt64(c format=\'\\\\0\')=>Read<ulong,UInt64P>(format);\\r\\n    [M(I)]public b TryRead(out float value,c format=\'\\\\0\')=>X<float,SingleP>(out value,format);\\r\\n    [M(I)]public float ReadSingle(c format=\'\\\\0\')=>Read<float,SingleP>(format);\\r\\n    [M(I)]public b TryRead(out double value,c format=\'\\\\0\')=>X<double,DoubleP>(out value,format);\\r\\n    [M(I)]public double ReadDouble(c format=\'\\\\0\')=>Read<double,DoubleP>(format);\\r\\n    [M(I)]public b TryRead(out decimal value,c format=\'\\\\0\')=>X<decimal,DecimalP>(out value,format);\\r\\n    [M(I)]public decimal ReadDecimal(c format=\'\\\\0\')=>Read<decimal,DecimalP>(format);\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\n\\r\\n## Announce\\r\\nIn the next posts we will discuss:\\r\\n- Something not about consoles and encodings, enough\\r\\n\\r\\n## Links\\r\\n - [Sources](https://github.com/epeshk/epeshk.text)\\r\\n - [Nuget package](https://www.nuget.org/packages/Epeshk.Text/0.0.1)\\r\\n\\r\\n## Homework\\r\\n - Try `AsciiScanner` on [timus](https://timus.online) or [codeforces](https://codeforces.com)\\r\\n - Try to find some bugs and if you succeed, open the [issue](https://github.com/epeshk/epeshk.text/issues) about it"},{"id":"text-io-benchmarks","metadata":{"permalink":"/text-io-benchmarks","source":"@site/blog/2022-12-02-plain-text-io-benchmarks.mdx","title":"Text IO Benchmarks","description":"In the previous post, I discussed what affects plain-text IO performance. Now I benchmark different approaches for stdin/stdout IO in native and managed code.","date":"2022-12-02T00:00:00.000Z","formattedDate":"December 2, 2022","tags":[{"label":"text_io","permalink":"/tags/text-io"}],"readingTime":14.995,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"text-io-benchmarks","title":"Text IO Benchmarks","tags":["text_io"]},"prevItem":{"title":"Text IO Library","permalink":"/plain-text-io-lib"},"nextItem":{"title":"Text IO Performance","permalink":"/plain-text-io-perf"}},"content":"import Tabs from \'@theme/Tabs\';\\nimport TabItem from \'@theme/TabItem\';\\n\\nIn the [previous](2022-10-19-plain-text-io-perf.md) post, I discussed what affects plain-text IO performance. Now I benchmark different approaches for stdin/stdout IO in native and managed code.\\n\\nA typical choice for competitive programming is C++ language. Because it is native, it is considered fast, with no overhead, and with zero-cost abstractions. But is it true, especially for IO performance?\\n\\n\x3c!--truncate--\x3e\\n\\nThere are some popular tips for getting the best IO performance with C++:\\n- Prefer C-style `scanf/printf` over C++ `cin/cout` because they are much faster\\n- If you like `cin/cout` as easy-to-use constructs, reduce their cost by adding \\"magic spells\\" to your code. For the explanation of this \\"spells\\", please look into [Technical Report on C++ Performance, 5.6.7, page 63](https://www.stroustrup.com/Performance-TR.pdf#page=63)\\n   ```c++\\n   ios_base::sync_with_stdio(false);\\n   cin.tie(NULL);\\n   ```\\n- Use `\'\\\\n\'` instead of `std::endl` for line breaks\\n\\n:::tip\\n\\nFor best .NET IO performance, you should not use `Console` static methods directly, especially for the output.\\n\\nUse STDIN/STDOUT via StreamReader and StreamWriter instead:\\n\\n```csharp\\nusing var input = new StreamReader(Console.OpenStandardInput());\\nusing var output = new StreamWriter(Console.OpenStandardOutput());\\n\\nstring line = input.ReadLine();\\noutput.WriteLine(Process(line));\\n```\\n\\n:::\\n\\nI will test C++ and .NET IO and these tips against various compilers and scenarios.\\n\\nIt is not fully correct benchmark for plain-text IO. E.g. there is different hardware for Windows and Linux. It is only estimation based on a small number of cases. If you want to reproduce measurements in your environment or other test cases, you could start from the [benchmark sources](https://github.com/epeshk/TextIOBenchmarks).\\n\\nAll tested programs don\'t have any extraordinary gimmicks for performance, so it is indeed possible to write much performant code.\\n\\n### Benchmark running\\nI will use the [Benchmark.NET](https://benchmarkdotnet.org/index.html) for my measurements. Although this library was designed for benchmarking of the .NET code, it contains a lot of useful benchmarking stuff like test case combination, time measurement, statistics, aggregation, and result presentation. It is also a commonly known tool that makes benchmarks easy to modify and reproduce.\\n\\nThe benchmarked method will invoke another executable. Overhead was measured by an empty program run.\\n\\nMention that the input data are stored in memory. The output could be drained to `Stream.Null` or also stored in memory, e.g. for validation.\\n```csharp\\n[Benchmark]\\npublic void Run() => Run(ProgramExecutable, PreloadedInput)\\n\\npublic static void Run(string program, byte[] input)\\n{\\n  var psi = new ProcessStartInfo(program)\\n  {\\n    RedirectStandardInput = true,\\n    RedirectStandardOutput = true,\\n    CreateNoWindow = true\\n  };\\n\\n  var process = Process.Start(psi);\\n  var reader = Task.Run(() =>\\n    process.StandardOutput.BaseStream.CopyToAsync(Stream.Null));\\n\\n  var stdin = process.StandardInput.BaseStream;\\n  stdin.Write(input);\\n  stdin.Flush();\\n\\n  reader.Wait();\\n  process.WaitForExit();\\n}\\n```\\n\\n### Environment\\nOS: Windows 10, Ubuntu 22.04\\n\\nCompilers:\\n- Windows: MSVC 19.31.31107 from VS Community 2022, MinGW g++ 12.2.0\\n- Linux: g++\\n- both: .NET 7.0.0 JIT and NativeAOT\\n\\n- MSVC parameters: `/TP /MT /EHsc /GL /O2 /W3 /Za /std:c++latest /D _CRT_SECURE_NO_WARNINGS`\\n- g++ parameters: `-static -O2`\\n\\nI will only post a 64-bit case for readability, but you could test for 32-bit on your own\\n\\n### Input data\\n- pregenerated 6 digit random integers: $10^5 <= a_i < 10^6$, $N = 200000$\\n- 5800000 bytes (5.5 MB)\\n\\n### Scenario 0: Overhead\\n\\nIn this scenario, I measured an empty program run time, including process creation and startup overhead. Other results are NOT adjusted for it. For workload time only, you should subtract this overhead manually.\\n\\n<details><summary>Windows</summary>\\n<p>\\n\\n| Program   | Compiler  | Median |\\n|-----------|-----------|-------:|\\n| empty_cpp | g++64     |  14 ms |\\n| empty_cpp | msvc64    |  14 ms |\\n| empty_cs  | NativeAOT |  19 ms |\\n| empty_cs  | JIT       |  36 ms |\\n| empty_kt  | JIT       |  75 ms |\\n\\n</p>\\n</details>\\n\\n<details><summary>Linux</summary>\\n<p>\\n\\n| Program   | Compiler  | Median |\\n|-----------|-----------|-------:|\\n| empty_cpp | g++64     | 0.3 ms |\\n| empty_cs  | NativeAOT | 1.5 ms |\\n| empty_kt  | JVM       |  16 ms |\\n| empty_cs  | JIT       |  70 ms |\\n\\n</p>\\n</details>\\n\\nThe overhead for a native binary on Linux is significantly lower than on Windows, likely because creating the new process with the `fork` call is much faster.\\n\\nFor managed applications, startup time on Linux is significantly worse, so I have decided to open [the issue](https://github.com/dotnet/runtime/issues/79206) regarding this.\\n\\n### Scenario 1: Input\\n\\nIn this scenario program should read a 5 MB input and then output a short answer (XOR of the numbers), only for correctness check.\\n\\n#### Programs\\n\\n- cin \u2014 `std::cin` used for reading\\n- cin_fast/cin_cout_fast \u2014 `std::cin` used for reading, configured with `sync_with_stdio` and `tie`\\n- scanf \u2014 `scanf` used for reading\\n- fastscan \u2014 custom parsing, based on `_getchar_nolock` on Windows and `getchar_unlocked` on Linux\\n- slowscan (C#) \u2014 custom parsing, based on `Console.Read`\\n- fastscan (C#) \u2014 custom parsing, based on `StreamReader.Read`\\n\\n<Tabs>\\n<TabItem value=\\"cs_console\\" label=\\"console\\">\\n\\n```csharp\\nint N = int.Parse(Console.ReadLine());\\n\\nint a_xor = 0, b_xor = 0, c_xor = 0, d_xor = 0;\\n\\nfor (var i = 0; i < N; ++i)\\n{\\n  var numbers = Console.ReadLine().Split();\\n  a_xor ^= int.Parse(numbers[0]); // (int)double.Parse(numbers[0], CultureInfo.InvariantCulture);\\n  b_xor ^= int.Parse(numbers[1]);\\n  c_xor ^= int.Parse(numbers[2]);\\n  d_xor ^= int.Parse(numbers[3]);\\n}\\n\\nConsole.WriteLine($\\"{a_xor} {b_xor} {c_xor} {d_xor}\\");\\n```\\n\\n</TabItem>\\n<TabItem value=\\"cs_slowscan\\" label=\\"slowscan\\">\\n\\n```csharp\\nint N = slowscan();\\n\\nint a_xor = 0, b_xor = 0, c_xor = 0, d_xor = 0;\\n\\nfor (var i = 0; i < N; ++i)\\n{\\n  a_xor ^= slowscan();\\n  b_xor ^= slowscan();\\n  c_xor ^= slowscan();\\n  d_xor ^= slowscan();\\n}\\n\\nConsole.WriteLine($\\"{a_xor} {b_xor} {c_xor} {d_xor}\\");\\n\\nstatic int slowscan()\\n{\\n  bool negative = false;\\n  bool read_start = false;\\n\\n  int number = 0;\\n\\n  while (true)\\n  {\\n    int c = Console.Read();\\n    if (c==\'-\')\\n    {\\n      negative = true;\\n      read_start = true;\\n      continue;\\n    }\\n\\n    if (c is >= \'0\' and <= \'9\')\\n    {\\n      number = number * 10 + (c - \'0\');\\n      read_start = true;\\n      continue;\\n    }\\n\\n    if (read_start)\\n      break;\\n  }\\n\\n  return negative ? -number : number;\\n}\\n```\\n\\n</TabItem>\\n<TabItem value=\\"cs_fastscan\\" label=\\"fastscan#\\">\\n\\n```csharp\\nusing var input = new StreamReader(Console.OpenStandardInput());\\n\\nint N = fastscan();\\n\\nint a_xor = 0, b_xor = 0, c_xor = 0, d_xor = 0;\\n\\nfor (var i = 0; i < N; ++i)\\n{\\n  a_xor ^= fastscan();\\n  b_xor ^= fastscan();\\n  c_xor ^= fastscan();\\n  d_xor ^= fastscan();\\n}\\n\\nConsole.WriteLine($\\"{a_xor} {b_xor} {c_xor} {d_xor}\\");\\n\\nint fastscan()\\n{\\n  bool negative = false;\\n  bool read_start = false;\\n\\n  int number = 0;\\n\\n  while (true)\\n  {\\n    int c = input.Read();\\n    if (c==\'-\')\\n    {\\n      negative = true;\\n      read_start = true;\\n      continue;\\n    }\\n\\n    if (c is >= \'0\' and <= \'9\')\\n    {\\n      number = number * 10 + (c - \'0\');\\n      read_start = true;\\n      continue;\\n    }\\n\\n    if (read_start)\\n      break;\\n  }\\n\\n  return negative ? -number : number;\\n}\\n```\\n\\n</TabItem>\\n<TabItem value=\\"fastscan\\" label=\\"fastscan\\">\\n\\n```cpp\\n#include <iostream>\\n#include <ios>\\nusing namespace std;\\n\\nint fastscan()\\n{\\n  bool negative = false;\\n  bool read_start = false;\\n\\n  int number = 0;\\n\\n  while (true)\\n  {\\n\\n#ifdef _WIN32\\n    int c = _getchar_nolock();\\n#else\\n    int c = getchar_unlocked();\\n#endif\\n    if (c==\'-\')\\n    {\\n      negative = true;\\n      read_start = true;\\n      continue;\\n    }\\n\\n    if (\'0\' <= c && c <= \'9\')\\n    {\\n      number = number * 10 + (c - \'0\');\\n      read_start = true;\\n      continue;\\n    }\\n\\n    if (read_start)\\n      break;\\n  }\\n\\n  return negative ? -number : number;\\n}\\n\\nint main()\\n{\\n  int t = fastscan();\\n  int a_xor = 0, b_xor = 0, c_xor = 0, d_xor = 0;\\n\\n  for (int i = 0; i < t; ++i) {\\n    a_xor ^= fastscan();\\n    b_xor ^= fastscan();\\n    c_xor ^= fastscan();\\n    d_xor ^= fastscan();\\n  }\\n\\n  printf(\\"%d %d %d %d\\\\n\\", a_xor, b_xor, c_xor, d_xor);\\n}\\n```\\n\\n</TabItem>\\n<TabItem value=\\"cin_fast\\" label=\\"cin_fast\\">\\n\\n```cpp\\n#include <iostream>\\n#include <ios>\\nusing namespace std;\\n\\nint main()\\n{\\n  ios_base::sync_with_stdio(false);\\n  cin.tie(NULL);\\n\\n  int t;\\n  cin >> t;\\n\\n  int a_xor = 0, b_xor = 0, c_xor = 0, d_xor = 0;\\n\\n  for (int i = 0; i < t; ++i) {\\n    int a, b, c, d;\\n\\n    cin >> a >> b >> c >> d;\\n\\n    a_xor ^= a;\\n    b_xor ^= b;\\n    c_xor ^= c;\\n    d_xor ^= d;\\n  }\\n\\n  cout << a_xor << \' \' << b_xor << \' \' << c_xor << \' \' << d_xor;\\n}\\n```\\n\\n</TabItem>\\n<TabItem value=\\"cin\\" label=\\"cin\\">\\n\\n```cpp\\n#include <iostream>\\n#include <ios>\\nusing namespace std;\\n\\nint main()\\n{\\n  int t;\\n  cin >> t;\\n\\n  int a_xor = 0, b_xor = 0, c_xor = 0, d_xor = 0;\\n\\n  for (int i = 0; i < t; ++i) {\\n    int a, b, c, d;\\n\\n    cin >> a >> b >> c >> d;\\n\\n    a_xor ^= a;\\n    b_xor ^= b;\\n    c_xor ^= c;\\n    d_xor ^= d;\\n  }\\n\\n  cout << a_xor << \' \' << b_xor << \' \' << c_xor << \' \' << d_xor;\\n}\\n```\\n\\n</TabItem>\\n<TabItem value=\\"scanf\\" label=\\"scanf\\">\\n\\n```cpp\\n#include <iostream>\\n#include <ios>\\nusing namespace std;\\n\\nint main()\\n{\\n  ios_base::sync_with_stdio(false);\\n  cin.tie(NULL);\\n\\n  int t;\\n  scanf(\\"%d\\", &t);\\n\\n  int a_xor = 0, b_xor = 0, c_xor = 0, d_xor = 0;\\n\\n  for (int i = 0; i < t; ++i) {\\n    int a, b, c, d;\\n    scanf(\\"%d%d%d%d\\", &a, &b, &c, &d);\\n\\n    a_xor ^= a;\\n    b_xor ^= b;\\n    c_xor ^= c;\\n    d_xor ^= d;\\n  }\\n\\n  printf(\\"%d %d %d %d\\\\n\\", a_xor, b_xor, c_xor, d_xor);\\n}\\n```\\n\\n</TabItem>\\n<TabItem value=\\"scanner\\" label=\\"scanner\\">\\n\\n```kt\\nimport java.util.*\\n\\nfun main() {\\n    val sc = Scanner(System.`in`)\\n\\n    val n = sc.nextInt()\\n\\n    var a_x = 0\\n    var b_x = 0\\n    var c_x = 0\\n    var d_x = 0\\n\\n    for (i in 0 until n) {\\n        val a = sc.nextInt()\\n        val b = sc.nextInt()\\n        val c = sc.nextInt()\\n        val d = sc.nextInt()\\n        a_x = a_x xor a\\n        b_x = b_x xor b\\n        c_x = c_x xor c\\n        d_x = d_x xor d\\n    }\\n\\n    println(\\"$a_x $b_x $c_x $d_x\\")\\n}\\n```\\n\\n</TabItem>\\n<TabItem value=\\"tokenizer\\" label=\\"token\\">\\n\\n```kt\\nimport java.io.BufferedReader\\nimport java.io.InputStreamReader\\nimport java.io.StreamTokenizer\\n\\nfun main() {\\n  val sc = StreamTokenizer(\\n    BufferedReader( // +100ms without buffering\\n      InputStreamReader(System.`in`, \\"ISO-8859-1\\")))\\n\\n  sc.nextToken()\\n  val n = sc.nval.toInt()\\n\\n  var a_x = 0\\n  var b_x = 0\\n  var c_x = 0\\n  var d_x = 0\\n\\n  for (i in 0 until n) {\\n      sc.nextToken()\\n      val a = sc.nval.toInt()\\n      sc.nextToken()\\n      val b = sc.nval.toInt()\\n      sc.nextToken()\\n      val c = sc.nval.toInt()\\n      sc.nextToken()\\n      val d = sc.nval.toInt()\\n      a_x = a_x xor a\\n      b_x = b_x xor b\\n      c_x = c_x xor c\\n      d_x = d_x xor d\\n  }\\n\\n  println(\\"$a_x $b_x $c_x $d_x\\")\\n}\\n```\\n\\n</TabItem>\\n</Tabs>\\n\\n<details><summary>Windows</summary>\\n<p>\\n\\n|  Program |Lang |  Compiler | Mean (Int) | Mean (Double) |\\n|--------- |---- |---------- |-----------:|--------------:|\\n| fastscan | C++ |    msvc64 |      34 ms |             - |\\n| fastscan | C#  | NativeAOT |      36 ms |             - |\\n| fastscan | C++ |     g++64 |      45 ms |             - |\\n| fastscan | C#  |       JIT |      58 ms |             - |\\n|  console | C#  | NativeAOT |      58 ms |         92 ms |\\n| cin_fast | C++ |     g++64 |      74 ms |       1650 ms |\\n|    scanf | C++ |    msvc64 |      76 ms |        100 ms |\\n|  console | C#  |       JIT |      85 ms |        117 ms |\\n|    token | Kt  |       JVM |     121 ms |        121 ms |\\n| slowscan | C#  |       JIT |     117 ms |             - |\\n| slowscan | C#  | NativeAOT |     121 ms |             - |\\n|    scanf | C++ |     g++64 |     190 ms |        310 ms |\\n| cin_fast | C++ |    msvc64 |     243 ms |        274 ms |\\n|      cin | C++ |    msvc64 |     271 ms |        300 ms |\\n|      cin | C++ |     g++64 |     424 ms |       2000 ms |\\n|  scanner | Kt  |       JVM |     485 ms |       2000 ms |\\n\\n</p>\\n</details>\\n\\n<details><summary>Linux</summary>\\n<p>\\n\\n|  Program |Lang |  Compiler | Mean (Int) | Mean (Double) |\\n|--------- |---- |---------- |-----------:|--------------:|\\n| fastscan | C++ |     g++64 |      14 ms |             - |\\n| fastscan | C#  | NativeAOT |      27 ms |             - |\\n| cin_fast | C++ |     g++64 |      38 ms |        101 ms |\\n|    scanf | C++ |     g++64 |      44 ms |         70 ms |\\n|  console | C#  | NativeAOT |      64 ms |        117 ms |\\n|    token | Kt  |       JVM |      97 ms |         97 ms |\\n| slowscan | C#  | NativeAOT |     125 ms |             - |\\n|      cin | C++ |     g++64 |     150 ms |        220 ms |\\n|  console | C#  |       JIT |     160 ms |        200 ms |\\n| slowscan | C#  |       JIT |     230 ms |             - |\\n|  scanner | Kt  |       JVM |     500 ms |       1080 ms |\\n\\n</p>\\n</details>\\n\\nAs we can see, .NET performs for input very well in this scenario. And Java `Scanner` which is based on the regular expressions is outsider.\\n\\n### Scenario 2: Echo\\n\\nIn this scenario, input and output are equal.\\nIt simulates a typical programming contest problem where the program reads a number of queries from input and outputs the answer for each query.\\n\\nSince the input is static and not dependent on the output, synchronization between STDIN and STDOUT is unnecessary.\\n\\nEcho (read, parse, and write) 200000 lines with 4 numbers each\\n\\n<Tabs>\\n<TabItem value=\\"cs_console\\" label=\\"console (C#)\\">\\n\\n```csharp\\nint N = int.Parse(Console.ReadLine());\\n\\nfor (var i = 0; i < N; ++i)\\n{\\n  var numbers = Console.ReadLine().Split();\\n  int a = int.Parse(numbers[0]); // (int)double.Parse(numbers[0], CultureInfo.InvariantCulture);\\n  int b = int.Parse(numbers[1]);\\n  int c = int.Parse(numbers[2]);\\n  int d = int.Parse(numbers[3]);\\n\\n  Console.WriteLine($\\"{a} {b} {c} {d}\\");\\n}\\n```\\n\\n</TabItem>\\n<TabItem value=\\"cs_stream\\" label=\\"stream (C#)\\">\\n\\n```csharp\\nusing var input = new StreamReader(Console.OpenStandardInput());\\nusing var output = new StreamWriter(Console.OpenStandardOutput());\\n\\nint N = int.Parse(input.ReadLine());\\n\\nfor (var i = 0; i < N; ++i)\\n{\\n  var numbers = input.ReadLine().Split();\\n  int a = int.Parse(numbers[0]); // (int)double.Parse(numbers[0], CultureInfo.InvariantCulture);\\n  int b = int.Parse(numbers[1]);\\n  int c = int.Parse(numbers[2]);\\n  int d = int.Parse(numbers[3]);\\n\\n  output.WriteLine($\\"{a} {b} {c} {d}\\");\\n}\\n```\\n\\n</TabItem>\\n<TabItem value=\\"cin_cout_fast\\" label=\\"cin_cout_fast\\">\\n\\n```cpp\\n#include <iostream>\\n#include <ios>\\nusing namespace std;\\n\\nint main()\\n{\\n  ios_base::sync_with_stdio(false);\\n  cin.tie(NULL);\\n\\n  int t;\\n  cin >> t;\\n\\n  for (int i = 0; i < t; ++i) {\\n    int a, b, c, d;\\n\\n    cin >> a >> b >> c >> d;\\n\\n    cout << a << \' \' << b << \' \' << c << \' \' << d << \'\\\\n\';\\n  }\\n}\\n```\\n\\n</TabItem>\\n<TabItem value=\\"cin\\" label=\\"cin\\">\\n\\n```cpp\\n#include <iostream>\\n#include <ios>\\nusing namespace std;\\n\\nint main()\\n{\\n  int t;\\n  cin >> t;\\n\\n  for (int i = 0; i < t; ++i) {\\n    int a, b, c, d;\\n\\n    cin >> a >> b >> c >> d;\\n\\n    cout << a << \' \' << b << \' \' << c << \' \' << d << \'\\\\n\';\\n  }\\n}```\\n\\n</TabItem>\\n<TabItem value=\\"scanf_printf\\" label=\\"scanf_printf\\">\\n\\n```cpp\\n#include <iostream>\\n#include <ios>\\nusing namespace std;\\n\\nint main()\\n{\\n  ios_base::sync_with_stdio(false);\\n  cin.tie(NULL);\\n\\n  int t;\\n  scanf(\\"%d\\", &t);\\n\\n  for (int i = 0; i < t; ++i) {\\n    int a, b, c, d;\\n    scanf(\\"%d%d%d%d\\", &a, &b, &c, &d);\\n    printf(\\"%d %d %d %d\\\\n\\", a, b, c, d);\\n  }\\n}\\n```\\n\\n\\n\\n</TabItem>\\n</Tabs>\\n\\n\\n<details><summary>Windows</summary>\\n<p>\\n\\n|       Program |Lang |  Compiler |      Mean | Mean (Double) |\\n|-------------- |---- |---------- |----------:|--------------:|\\n|        stream | C#  | NativeAOT |     87 ms |        262 ms |\\n| cin_cout_fast | C++ |     g++64 |    109 ms |       1911 ms |\\n|        stream | C#  |       JIT |    118 ms |        225 ms |\\n|  printf_scanf | C++ |    msvc64 |    130 ms |        260 ms |\\n|  printf_scanf | C++ |     g++64 |    280 ms |        470 ms |\\n|       console | C#  | NativeAOT |    300 ms |        580 ms |\\n|       console | C#  |       JIT |    350 ms |        560 ms |\\n| cin_cout_fast | C++ |    msvc64 |    440 ms |        680 ms |\\n|      cin_cout | C++ |    msvc64 |    800 ms |       1050 ms |\\n|      cin_cout | C++ |     g++64 |    820 ms |       2790 ms |\\n\\n</p>\\n</details>\\n<details><summary>Linux</summary>\\n<p>\\n\\n|       Program |Lang | Compiler | Mean (Int) | Mean (Double) |\\n|-------------- |---- |--------- |-----------:|--------------:|\\n| cin_cout_fast | C++ |    g++64 |      80 ms |        376 ms |\\n|         scanf | C++ |    g++64 |      82 ms |        260 ms |\\n|        stream | C#  |NativeAOT |     104 ms |        240 ms |\\n|        stream | C#  |      JIT |     225 ms |        370 ms |\\n|       console | C#  |NativeAOT |     310 ms |        500 ms |\\n|       console | C#  |      JIT |     415 ms |        580 ms |\\n|      cin_cout | C++ |    g++64 |     430 ms |        800 ms |\\n\\n</p>\\n</details>\\n\\n## Conclusion\\nThe performance of text IO varies greatly depending on the target platform, runtime, compiler, and compiler flags, which explains the abundance of misconceptions on the subject. As we have seen, every platform and language can be \\"slow\\" if performance is not taken into consideration.\\n\\nFor C#, the advice for writing high-performance text IO code is to use the STDIN/STDOUT streams instead of the static `Console` methods. This is not so important for input, but it provides a significant speedup for output, as the `Console.Write/WriteLine` methods flush the output stream to the underlying OS buffer after each write operation. This may be useful for interactive console applications, but performance killer for data-intensive IO.\\n\\n## Announce\\nIn the next posts we will discuss:\\n- Efficient plain-text input reading implementation on .NET\\n\\n## Links\\n - [High throughput Fizz Buzz](https://codegolf.stackexchange.com/questions/215216/high-throughput-fizz-buzz)\\n\\n## Homework\\n - Write a high throughput Fizz Buzz on any .NET language\\n\\n<details><summary>Previous homework writeup</summary>\\n<p>\\n\\nThe [1510 problem](https://timus.online/problem.aspx?space=1&num=1510&locale=en) has tight memory limits: 16 MB for 500000 up to 10 digit integers.\\n\\nWhile this does not prevent storing all the input in memory, because $sizeof(int)*500000 < 16 MB$, each integer serialized as a .NET `string` occupies significantly more space:\\n\\n - 16 bytes for header and method table pointer on x64\\n - 4 bytes for string length\\n - 20 bytes for 10 UTF-16 characters\\n - 2 bytes for null terminator char\\n\\nSo, ~42 bytes for 10 characters. $42 * 500000 = 21 * 10^6 > 16 MB$\\n\\nYes, these strings are short-lived, but it is not guaranteed that the GC will clean them up and reclaim memory during program\'s run time. Even a solution using a `StreamReader` will fail with a Memory Limit Exceed verdict!\\n\\nForcing garbage collection with `GC.Collect` may lead to Time Limit. What to do? Adapt the C++ `fastscan` code from the previous article for C#. Or, for now, just use the code from this article.\\n\\n </p>\\n </details>"},{"id":"plain-text-io-perf","metadata":{"permalink":"/plain-text-io-perf","source":"@site/blog/2022-10-19-plain-text-io-perf.md","title":"Text IO Performance","description":"In the previous post, I discussed the usability flaws of plain-text input parsing in .NET platform. In this post, we will focus on performance issues related to plain-text input and output.","date":"2022-10-19T00:00:00.000Z","formattedDate":"October 19, 2022","tags":[{"label":"text_io","permalink":"/tags/text-io"}],"readingTime":4.775,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"plain-text-io-perf","title":"Text IO Performance","tags":["text_io"]},"prevItem":{"title":"Text IO Benchmarks","permalink":"/text-io-benchmarks"},"nextItem":{"title":"The flaw that reduces C# and .NET popularity","permalink":"/text-io-flaw"}},"content":"In the [previous post](2022-10-06-plain-text-io-flaw.md), I discussed the usability flaws of plain-text input parsing in .NET platform. In this post, we will focus on performance issues related to plain-text input and output.\\n\\nPlain-text IO performance is a big issue for competitive programming. If the input or output is too large, the solution may get Time Limit or Memory Limit exceeded verdict due to inefficient IO. IO will be a bottleneck.\\n\\nConsider the problem [Timus: 1510](https://acm.timus.ru/problem.aspx?space=1&num=1510&locale=en).\\nEven a tricky C# solution with optimal $O(n)$ complexity got Memory Limit Exceeded verdict due to inefficient input parsing. But nonoptimal C++ solution with $O(nlog(n))$ complexity easily got Accepted. The choice of language is a game changer in this case.\\n\\n\x3c!--truncate--\x3e\\n\\n## Which affects plain text IO performance\\nMany things affects plain text IO performance. Let\'s discuss some of this things in theory to set up a correct benchmark.\\n\\n### Data source and target\\nBefore reach the program, input data should be loaded from disk or generated by another program. Thus, speed of the disk or efficiency of the generator program may affect benchmark result.\\n\\nIf the output stream is piped to a slow application, like terminals, there also will be an issue. Both input and output streams are implemented over bounded buffers, thus our application will be blocked when the terminal app renders old text.\\n\\nNote that redirecting the output e.g. to `> nul` on Windows will lead to false benchmark results because no output will be generated at all (the stdout pipe will not be created at all).\\n\\nI will get around these issues in the benchmarks by storing input and output data in memory.\\n\\n### Operating system\\nIO streams (pipes) are a tool to pass data from one process to another, managed by the operating system. So, the operating system is responsible for the efficiency of APIs, used to access the internal pipe\'s buffer.\\n\\nAlso blocking may happen where the pipe\'s buffer is full on write or empty on reading. In this case, the OS thread scheduler is involved.\\n\\n### Language runtime\\nProgramming languages and frameworks abstract the hardware and OS from a programmer, providing an abstraction layer over platform-specific implementation details. The transformation from raw `STD_INPUT_HANDLE` to nice `TextReader` may require hard CPU and memory bus work, like converting, copying, and additional buffering of the data.\\n\\nLanguage runtime is also responsible for encoding, decoding, and parsing text data.\\n\\nEven for single language, runtime behavior may differ. For C++ we should test against different compilers, and for C# against .NET Framework and modern .NET like 6 and 7.\\n\\n### Encoding\\nNo text is just plain. The stdin/stdout content is a sequence of bytes, and it is a program\'s responsibility to interpret it with some encoding. The most common encodings for files are ASCII and UTF-8 (which is the same in range 0-127), but .NET strings use UTF-16. So, the input stream reading to `string` will require data re-encoding.\\n\\n```\\nascii(\\"-13\\") = 2d 31 33\\nutf8 (\\"-13\\") = 2d 31 33\\nutf16(\\"-13\\") = 2d 00 31 00 33 00\\n```\\n\\n### Allocations\\nAs I mentioned in the previous post, all popular methods for input parsing, like `Console.Readline()`, `string.Split()`, `.Select(int.Parse).ToArray()` will copy data and allocate new objects. This allocations take some time and memory. Then if the garbage collector will be triggered, it will also take some time to process and clean up these objects.\\n\\nThe worst case for .NET is a long single-line input. `Console.ReadLine()` will read all the input in memory, even if it\'s unnecessary.\\n\\n### Parsing\\nThe transformations from char sequence to number or backward may be tricky. I recommend you to look at [this Pull Request](https://github.com/dotnet/runtime/pull/62301) from [dotnet/runtime](https://github.com/dotnet/runtime) about `double` parsing for more information.\\n\\nIn some cases, it is worth reimplementing some things, like string to integer conversions, outperforming standard functions. For example, integer parsing may be implemented like this. Of course, this code is not suitable for all cases, but for some it is faster.\\n\\n```cpp\\nint fastscan()\\n{\\n    bool negative = false;\\n    bool read_start = false;\\n  \\n    int number = 0;\\n  \\n    while (true)\\n    {\\n\\n#ifdef _WIN32\\n        int c = _getchar_nolock();\\n#else\\n        int c = getchar_unlocked();\\n#endif\\n        if (c==\'-\')\\n        {\\n            negative = true;\\n            read_start = true;\\n            continue;\\n        }\\n  \\n        if (\'0\' <= c && c <= \'9\')\\n        {\\n            number = number * 10 + (c - \'0\');\\n            read_start = true;\\n            continue;\\n        }\\n\\n        if (read_start)\\n            break;\\n    }\\n\\n    return negative ? -number : number;\\n}\\n```\\n\\n### Flushing\\nThere are two scenarios for output writing:\\n- Interactive console applications, where the following input may depend on output. E.g. a chess program which plays with humans or another programs\\n- Non-interactive applications, which may print output after reading all the input.\\n\\nThe interactive output should be propagated to the STDOUT buffer as early as possible, typically line-by-line. But for non-interactive apps, it is not efficient to flush a small amount of data because it will wake the reader application thread only to process this small output and then block on waiting again. Instead, we want to accumulate the output in the own buffer and flush it to STDOUT rarely.\\n\\nMany language runtimes are configured for interactive apps by default. So for fast output, we should reconfigure this behavior.\\n\\n.NET methods like `Console.WriteLine`, `Console.Write` synchronizes access to the output stream and flush it. So you may improve C# output performance by writing to the buffered output stream:\\n```csharp\\nusing var output = new StreamWriter(Console.OpenStandardOutput());\\noutput.WriteLine(...);\\n```\\n\\n## Announce\\nIn the next post I\'ll set up benchmarks to check these concerns on practice and discuss the results.\\n\\nIn the following we will discuss:\\n- How to improve C#/.NET plain-text IO speed\\n- Number parsing algorithms\\n- Efficient plain-text input reading implementation on C#\\n\\n## Homework\\nSolve the [Timus: 1510](https://timus.online/problem.aspx?space=1&num=1510&locale=en) problem on C#."},{"id":"text-io-flaw","metadata":{"permalink":"/text-io-flaw","source":"@site/blog/2022-10-06-plain-text-io-flaw.md","title":"The flaw that reduces C# and .NET popularity","description":"In competitive programming contests, interviews, or when solving problems from archives for learning we are facing automatic judging systems. These systems accept code on some supported language, then compile and run it against many test cases.","date":"2022-10-06T00:00:00.000Z","formattedDate":"October 6, 2022","tags":[{"label":"text_io","permalink":"/tags/text-io"}],"readingTime":4.755,"hasTruncateMarker":true,"authors":[],"frontMatter":{"slug":"text-io-flaw","title":"The flaw that reduces C# and .NET popularity","tags":["text_io"]},"prevItem":{"title":"Text IO Performance","permalink":"/plain-text-io-perf"}},"content":"In competitive programming [contests](https://codeforces.com), interviews, or when solving problems from [archives](https://timus.online/?locale=en) for learning we are facing automatic judging systems. These systems accept code on some supported language, then compile and run it against many test cases.\\n\\nAlthough modern versions of C# are usually supported on these systems, I prefer to use C++, Java, or Kotlin for solving algorithmic problems. Why? Because judging systems provide test cases as plain text to STDIN and C# doesn\'t have a good way to read and parse it.\\n\\n\x3c!--truncate--\x3e\\n\\n## The Flaw\\n\\nLet\'s look at example. It is [\\"A+B problem\\"](https://timus.online/problem.aspx?space=1&num=1000&locale=en), demo problem used to get familiar with judging system.\\n```plain\\nStatement:\\nCalculate A + B (|A|, |B| <= 10^5)\\n\\nInput:\\nThe single line contains two integers, A and B, separated by one space\\n\\nOutput:\\nA+B value\\n\\nNotes:\\nUse + operator\\n```\\n\\nIt\'s simple, isn\'t it?\\n\\nLet\'s compare solutions for this problem in different programming languages.\\n\\n#### C:\\n```c\\n#include <stdio.h>\\n\\nint main()\\n{\\n    int a, b;\\n    scanf(\\"%d %d\\", &a, &b);\\n    printf(\\"%d\\", a + b);\\n}\\n```\\n\\n#### C++:\\n```c++\\n#include <iostream>\\nusing namespace std;\\n\\nint main()\\n{\\n    int a, b;\\n    cin >> a >> b;\\n    cout << a + b;\\n}\\n```\\n\\n#### Kotlin (Java solution similar to it, but much longer):\\n```kt\\nimport java.util.*\\n\\nfun main() {\\n    val sc = Scanner(System.`in`)\\n    val a = sc.nextInt()\\n    val b = sc.nextInt()\\n    print(a + b)\\n}\\n```\\n\\n#### C# with [Top-level statements](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/program-structure/top-level-statements) and [Global usings](https://blog.jetbrains.com/dotnet/2021/11/18/global-usings-in-csharp-10/) features:\\n```csharp\\nvar numbers = Console.ReadLine().Split();\\nvar a = int.Parse(numbers[0]);\\nvar b = int.Parse(numbers[1]);\\nConsole.WriteLine(a + b);\\n```\\n\\n#### Or, as C# one-liner:\\n```csharp\\nConsole.WriteLine(Console.ReadLine().Split().Select(int.Parse).Sum());\\n```\\n\\nAs we can see, C, C++, and Kotlin solutions just read two integers from the input. Instead, C# program should `.ReadLine()` the single line of the input, then `.Split()` it by whitespace character, then `.Parse` each part of the line to target type `int`.\\n\\nSo, when many other languages allow taking the input as a sequence of tokens of the given types, in C# we are forced to take the input as a `string` or `char`, then parse it manually. There\'s no simple abstraction that hides parsing complexity from a programmer in the .NET world.\\n\\nI prefer the C++ solution for this problem because the code in the `main` method is way shorter than others, only 32 characters without unnecessary whitespaces, and also clear to read. C# one-liner has 70 characters in total. For real, non-demo problems, C++ often is much harder to debug.\\n\\n## Why manual parsing is a disadvantage?\\n\\n### Flexibility to format changes\\nLet\'s go back to \\"A+B problem\\" and change the input format slightly.\\n\\n```diff    \\nInput:\\n- A single line contains two integers, A and B, separated by one space\\n+ A two lines, each line containing one integer\\n```\\n\\nC, C++, and Kotlin solutions remain unchanged. But the C# solution needs to be rewritten to support the new input format.\\n\\n```csharp\\nConsole.WriteLine(int.Parse(Console.ReadLine()) + int.Parse(Console.ReadLine()));\\n```\\n\\nIn this simple case, it is possible to write a C# solution that supports both input formats via the `Console.ReadToEnd()` method, but it is inconvenient when the input is more complex.\\n\\n### Mental complexity\\nWhen solving algorithmic problems you want to focus on an algorithm, and the correctness of the implementation, but not on the input formats, line endings, duplicated or invisible Unicode [whitespace characters](https://en.wikipedia.org/wiki/Whitespace_character), and other quirks. It\'s much less painful when it is handled by a bunch of prewritten code, ideally from the standard library.\\n\\nAlso, in programming contests, you want to save time, because the speed of problem-solving affects the final score.\\n\\n### Performance\\nObviously, if we write `int.Parse(Console.ReadLine())`, an intermediate `string` object will be allocated. This allocation takes some time and memory. Then if the garbage collector will be triggered, it will also take some time to process and clean up this object.\\n\\nIf the line contains more than one integer, an intermediate `int[]` array will be allocated in the `.Split()` method, with the same consequences.\\n\\nThere are also other performance problems with plain text IO, which are discussed in the *next* post.\\n\\n## Underestimation of this flaw\\n\\nThis disadvantage isn\'t dedicated to C# and other .NET languages. E.g. Python and Rust use the same approach for the plain text input reading. And it is not a disadvantage that we are facing in day-to-day work as software developers, because in production cases plain text input is very rare in comparison with JSON or other structured data formats.\\n\\nFor console applications, [System.CommandLine](https://learn.microsoft.com/en-us/dotnet/standard/commandline/) or another argument/input parsing library could be used instead. But judging systems limits us to standard library features and standardized plain text input format. And it\'s impossible to just install some fancy NuGet package in these systems.\\n\\nBut why is this important at all?\\n- Solving algorithmic problems and participating in programming contests are great ways to learn new things and improve your programming skills. The ability to flawlessly use familiar programming language greatly simplifies it, especially for beginners.\\n- This feature could help to promote the language among developers as a tool for solving algorithmic problems on automatic judging systems.\\n- For newbies who learn programming during solving algorithmic problems, this will help to choose C# and .NET instead of another language and platform.\\n\\n## What to do with it?\\n\\nThere is already [.NET API Proposal](https://github.com/dotnet/runtime/issues/64621) that describes this issue. This proposal is far from well-written but contains a discussion about the usefulness of this feature and design decisions. Most likely, if this feature will be implemented, it will look like Java `Scanner` class.\\n\\nIf you also find this feature useful \u2014 please upvote the GitHub issue!\\n\\n## Announce\\nIn the next posts we will discuss:\\n- A performance problems with plain text IO\\n- Efficient plain text input reading implementation"}]}')}}]);